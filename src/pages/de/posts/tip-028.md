---
layout: /src/layouts/Layout.astro
title: "Wie hoch ist die ZeitkomplexitÃ¤t (Big O) meines Codes?"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "Coding/Entwicklung"
description: "Ein Prompt, der die Zeit- und RaumkomplexitÃ¤t Ihres Algorithmus analysiert und OptimierungsmÃ¶glichkeiten findet."
tags:
  [
    "Algorithmus",
    "ZeitkomplexitÃ¤t",
    "Big-O",
    "Performance-Optimierung",
    "CS-Wissen",
  ]
lang: de
---

# ğŸ“ Wie hoch ist die ZeitkomplexitÃ¤t (Big O) meines Codes?

> **ğŸ¯ Empfohlene Zielgruppe:** Alle
> **â±ï¸ Zeitaufwand:** 5 Minuten
> **ğŸ¤– Empfohlenes Modell:** Alle KI-Modelle

| Schwierigkeit | EffektivitÃ¤t |  Nutzen   |
| :-----------: | :----------: | :-------: |
|    â­â­â˜†â˜†â˜†    |  â­â­â­â­â­  | â­â­â­â­â˜† |

_"Da sind zwei verschachtelte for-Schleifen... Ist das O(N) oder O(N^2)?"_

Wenn Sie Coding-Tests machen oder Logik fÃ¼r hohen Traffic schreiben, ist die Analyse der ZeitkomplexitÃ¤t (Time Complexity) unerlÃ¤sslich.
Aber wenn rekursive Aufrufe in Schleifen oder komplexe Bedingungen hinzukommen, bekommt man Kopfschmerzen beim Berechnen, oder?
Zeigen Sie der KI Ihren Code, und sie analysiert ihn prÃ¤zise in Big-O-Notation und schlÃ¤gt sogar effizientere Algorithmen vor.

---

## âš¡ï¸ Zusammenfassung in 3 Zeilen (TL;DR)

1. Genaue Berechnung von Zeit- und RaumkomplexitÃ¤t (Big-O)
2. Identifizierung von LeistungsengpÃ¤ssen (Bottlenecks)
3. Vorschlag verbesserter Algorithmen mit geringerer KomplexitÃ¤t

---

## ğŸš€ LÃ¶sung: "Complexity Analyzer"

### ğŸ¥‰ Basic Version (Basis-Version)

Verwenden Sie dies, wenn Sie schnell nur das Ergebnis benÃ¶tigen.

> **Rolle:** Du bist Informatik-Professor und Experte fÃ¼r Algorithmen-Optimierung.
> **Anfrage:** Analysiere die Zeit- und RaumkomplexitÃ¤t meines Algorithmus und finde Punkte zur Leistungsverbesserung.

<br>

### ğŸ¥‡ Pro Version (Experten-Version)

Verwenden Sie dies, wenn Sie detaillierte QualitÃ¤t benÃ¶tigen.

Kopieren Sie den **PROMPT**-Inhalt unten und verwenden Sie ihn.

> **Rolle (Role):** Du bist Informatik-Professor und Experte fÃ¼r Algorithmen-Optimierung.
>
> **Situation (Context):** Ich bin neugierig auf die Leistung meines Algorithmus. Ich mÃ¶chte wissen, ob er effizient ist oder verbessert werden muss.
>
> **Anfrage (Task):**
>
> 1. Analysiere die **ZeitkomplexitÃ¤t (Time Complexity)** und **RaumkomplexitÃ¤t (Space Complexity)** des bereitgestellten Codes in der Big-O-Notation.
> 2. BegrÃ¼nde Zeile fÃ¼r Zeile, warum diese KomplexitÃ¤t entsteht.
> 3. Wenn es eine effizientere Methode gibt (z. B. O(N^2) -> O(N log N)), erklÃ¤re sie zusammen mit dem verbesserten Code.
>
> **Code:**
>
> ```
> [FÃ¼gen Sie hier den zu analysierenden Code ein]
> ```
>
> **EinschrÃ¤nkungen (Constraints):**
>
> - Analysiere basierend auf dem Worst Case (schlechtester Fall).
> - ErwÃ¤hne Probleme, die auftreten kÃ¶nnen, wenn die GrÃ¶ÃŸe der Eingabedaten (N) sehr groÃŸ ist.

---

## ğŸ§¬ Prompt-Analyse (Warum es funktioniert?)

---

## ğŸ“Š Beweis: Vorher & Nachher

### âŒ Before (Eingabecode)

```python
def find_duplicate(nums):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j]:
                return nums[i]
    return None
```

### âœ… After (Ergebnis)

**Analyse:**

- **ZeitkomplexitÃ¤t:** O(N^2). Es werden verschachtelte `for`-Schleifen verwendet. Schon bei N > 10.000 wird es sehr langsam.
- **RaumkomplexitÃ¤t:** O(1). Es wird fast kein zusÃ¤tzlicher Speicher verwendet.

**Verbesserter Code (Verwendung von Hash Set):**

```python
def find_duplicate_optimized(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None
```

**Ergebnis der Verbesserung:**

- **ZeitkomplexitÃ¤t:** O(N). Die Schleife wird nur einmal durchlaufen.
- **RaumkomplexitÃ¤t:** O(N). Daten mÃ¼ssen im `seen`-Set gespeichert werden. (Time-Space Tradeoff)

---

## ğŸ¯ Fazit

HÃ¶ren Sie auf zu denken "Es lÃ¤uft ja, also gut".
Ein Entwickler, der sich auch um unsichtbare Leistung kÃ¼mmert, ist ein wahrer Profi. Trainieren Sie Ihre Algorithmus-Muskeln mit dem Feedback des KI-Professors! ğŸ·
