---
layout: /src/layouts/Layout.astro
title: "Â¿CuÃ¡l es la complejidad temporal (Big O) de mi cÃ³digo?"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "Desarrollo"
description: "Un prompt que analiza la complejidad temporal y espacial del algoritmo escrito y encuentra puntos de mejora de rendimiento."
tags:
  [
    "Algoritmo",
    "ComplejidadTemporal",
    "Big-O",
    "OptimizaciÃ³n",
    "ConocimientoCS",
  ]
lang: es
---

# ğŸ“ Â¿CuÃ¡l es la complejidad temporal (Big O) de mi cÃ³digo?

> **ğŸ¯ Recomendado para:** Todos
> **â±ï¸ Tiempo:** 5 minutos
> **ğŸ¤– Modelo recomendado:** Todos los modelos de IA

| Dificultad | Efectividad | Utilidad  |
| :--------: | :---------: | :-------: |
|  â­â­â˜†â˜†â˜†   | â­â­â­â­â­  | â­â­â­â­â˜† |

_"Hay dos bucles for anidados... Â¿Esto es O(N) o O(N^2)?"_

Analizar la complejidad temporal (Time Complexity) es esencial al hacer pruebas de codificaciÃ³n o programar lÃ³gica para manejar mucho trÃ¡fico.
Pero si hay llamadas recursivas dentro de un bucle o las condiciones se complican, Â¿te duele la cabeza calcularlo?
Muestra el cÃ³digo a la IA y lo analizarÃ¡ con precisiÃ³n en notaciÃ³n Big-O, e incluso sugerirÃ¡ algoritmos mÃ¡s eficientes.

---

## âš¡ï¸ Resumen en 3 lÃ­neas (TL;DR)

1. CÃ¡lculo preciso de complejidad temporal y espacial (Big-O).
2. IdentificaciÃ³n de cuellos de botella de rendimiento (Bottleneck).
3. Propuesta de algoritmos mejorados con menor complejidad.

---

## ğŸš€ SoluciÃ³n: "Analizador de Complejidad"

### ğŸ¥‰ VersiÃ³n BÃ¡sica

Ãšsala cuando necesites resultados rÃ¡pidos.

> **Rol:** Eres un profesor de Ciencias de la ComputaciÃ³n (CS) y experto en optimizaciÃ³n de algoritmos.
> **Solicitud:** Un prompt que analiza la complejidad temporal y espacial del algoritmo escrito y encuentra puntos de mejora de rendimiento.

<br>

### ğŸ¥‡ VersiÃ³n Pro (Experto)

Ãšsala cuando necesites calidad detallada.

Copia y pega el siguiente **PROMPT** en ChatGPT o Claude.

> **Rol:** Eres un profesor de Ciencias de la ComputaciÃ³n (CS) y experto en optimizaciÃ³n de algoritmos.
>
> **SituaciÃ³n:** Tengo curiosidad por el rendimiento del algoritmo que he escrito. Quiero saber si es eficiente o si necesita mejoras.
>
> **Solicitud:**
>
> 1. Analiza la **Complejidad Temporal (Time Complexity)** y la **Complejidad Espacial (Space Complexity)** del cÃ³digo proporcionado en notaciÃ³n Big-O.
> 2. Explica la razÃ³n de esa complejidad lÃ­nea por lÃ­nea.
> 3. Si hay una forma mÃ¡s eficiente (ej: O(N^2) -> O(N log N)), explÃ­cala junto con el cÃ³digo mejorado.
>
> **CÃ³digo:**
>
> ```
> [Pega aquÃ­ el cÃ³digo a analizar]
> ```
>
> **Restricciones:**
>
> - Analiza basÃ¡ndote en el peor de los casos (Worst Case).
> - Menciona los problemas que pueden surgir cuando el tamaÃ±o de los datos de entrada (N) es muy grande.

---

## ğŸ§¬ AnatomÃ­a del Prompt (Why it works?)

---

## ğŸ“Š Prueba: Antes y DespuÃ©s

### âŒ Antes (CÃ³digo de entrada)

```python
def find_duplicate(nums):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j]:
                return nums[i]
    return None
```

### âœ… DespuÃ©s (Resultado)

**AnÃ¡lisis:**

- **Complejidad Temporal:** O(N^2). Utiliza un doble bucle `for`. Se vuelve muy lento si N supera los 10,000.
- **Complejidad Espacial:** O(1). Apenas usa memoria adicional.

**CÃ³digo mejorado (Usando Hash Set):**

```python
def find_duplicate_optimized(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None
```

**Resultado de la mejora:**

- **Complejidad Temporal:** O(N). Recorre el bucle una sola vez.
- **Complejidad Espacial:** O(N). Necesita almacenar datos en el conjunto `seen`. (Time-Space Tradeoff)

---

## ğŸ¯ ConclusiÃ³n

Deja de pensar "funciona, asÃ­ que ya estÃ¡".
El desarrollador que cuida el rendimiento invisible es el verdadero experto. Â¡Desarrolla tu mÃºsculo algorÃ­tmico con el feedback del profesor IA! ğŸ·
