---
layout: /src/layouts/Layout.astro
title: "테스트 코드 짜기 귀찮죠? AI가 대신 짜드립니다"
author: "Zzabbis"
date: "2026-02-07T09:10:33.112Z"
updatedDate: "2026-02-07T09:10:33.112Z"
category: "개발"
description: "작성하기 번거로운 단위 테스트(Unit Test)를 엣지 케이스까지 완벽하게 고려하여 1분 만에 자동 생성하는 실전 프롬프트입니다."
tags: ["테스트코드", "TDD", "Jest", "JUnit"]
---

# 📝 테스트 코드 짜기 귀찮죠? AI가 대신 짜드립니다

- **🎯 추천 대상:** 백엔드/프론트엔드 개발자, QA 엔지니어, TDD 입문자
- **⏱️ 소요 시간:** 30분 → 1분 단축
- **🤖 추천 모델:** Claude 3.5 Sonnet, GPT-4o, Gemini 1.5 Pro (코딩 특화 모델 권장)

- ⭐ **난이도:** ⭐⭐☆☆☆
- ⚡️ **효과성:** ⭐⭐⭐⭐⭐
- 🚀 **활용도:** ⭐⭐⭐⭐⭐

> _"기능 배포하기도 바쁜데 테스트 코드까지 짜라고요? 하지만 테스트가 없으면 배포 버튼을 누를 때마다 심장이 철렁 내려앉습니다."_

안정적인 서비스를 위해 단위 테스트(Unit Test)는 선택이 아닌 필수입니다. 하지만 막상 짜려면 손이 많이 가고 엄청난 지루함이 몰려옵니다. 특히 예외 상황(Edge Case)까지 꼼꼼하게 챙기다 보면, 본 로직 구현보다 테스트 코드 작성에 더 많은 시간을 쏟게 되죠. 이제 이 지루하고 고된 작업은 AI에게 모두 맡기고, 당신은 핵심 비즈니스 로직과 아키텍처 설계에만 집중하세요.

---

## ⚡️ 3줄 요약 (TL;DR)

1. **단순 반복 작업 해방:** 번거로운 목(Mock) 객체 생성과 보일러플레이트 코드를 AI가 단 1분 만에 완성해 줍니다.
2. **빈틈없는 엣지 케이스:** 개발자가 놓치기 쉬운 예외 상황(Exception)과 경계값 테스트(Boundary Test)까지 알아서 챙겨줍니다.
3. **코드 커버리지 극대화:** QA 엔지니어의 페르소나를 부여해, 즉시 프로덕션 레벨에 적용 가능한 견고한 테스트를 생성합니다.

---

## 🚀 해결책: "테스트 커버리지 가디언"

### 🥉 Basic Version (기본형)

빠르게 함수 하나만 테스트하거나 형태만 잡고 싶을 때 사용하세요.

> **역할:** 너는 `[시니어 QA 엔지니어]`야.
> **요청:** 아래 작성된 코드에 대한 단위 테스트(Unit Test)를 `[사용 중인 프레임워크, 예: Jest]`를 사용해서 작성해 줘. 엣지 케이스도 꼭 포함해 줘.

<br>

### 🥇 Pro Version (전문가형)

TDD(테스트 주도 개발) 수준의 디테일과 높은 코드 커버리지가 필요할 때 사용하세요.
아래 **PROMPT** 내용을 복사해서 코딩 특화 AI(Claude 3.5 Sonnet 등)에게 붙여넣으세요.

> **역할 (Role):** 너는 10년 차 `[시니어 QA/테스트 엔지니어]`야.
>
> **상황 (Context):**
>
> - 목표: 내가 작성한 핵심 비즈니스 로직에 대한 견고한 단위 테스트 코드 구축.
> - 환경: 우리는 현재 `[테스트 프레임워크, 예: JUnit5 / Jest / PyTest]`를 사용 중이야.
>
> **요청 (Task):**
> 다음 4단계에 맞춰 제공된 코드의 단위 테스트를 완벽하게 작성해 줘.
>
> 1. 정상적인 입력에 대한 **성공 케이스(Happy Path)** 테스트 작성.
> 2. 발생할 수 있는 **예외 상황과 엣지 케이스(Edge Case)**를 3가지 이상 스스로 식별하고, 이에 대한 실패/예외 처리 테스트 작성.
> 3. 필요한 경우, 외부 의존성을 격리하기 위한 **Mocking 전략** 적용 (예: Mockito, jest.fn() 등).
> 4. 각 테스트 메서드 상단에 [Given-When-Then] 패턴에 맞춰 이 테스트가 무엇을 검증하는지 한국어 주석 추가.
>
> **제약사항 (Constraints):**
>
> - 코드는 즉시 실행할 수 있는 완성된 형태로만 출력할 것. 불필요한 서론은 생략해.
> - 테스트 메서드 이름은 의도를 명확히 알 수 있게 직관적으로 지어줘.
>
> **테스트할 코드:**
> `[여기에 원본 코드를 붙여넣으세요]`

---

## 💡 작성자 코멘트 (Insight)

이 프롬프트의 핵심은 AI에게 단순한 '코더'가 아닌 **'시니어 QA 엔지니어'**라는 명확한 역할을 부여하는 것입니다.
실무에서 이 프롬프트를 사용할 때 가장 큰 효과를 보려면, AI가 생성한 '엣지 케이스' 목록을 꼼꼼히 리뷰해 보세요. 때로는 개발자인 내가 전혀 예상하지 못했던 경계값(Boundary value)이나 NullPointerException 발생 가능성을 AI가 먼저 찾아내어 테스트로 커버해 줍니다.
특히 기존 레거시 코드에 테스트를 덧붙여야 할 때, 이 프롬프트를 사용하면 코드 분석과 테스트 작성을 동시에 해결할 수 있어 생산성이 폭발적으로 상승합니다.

---

## 🙋 자주 묻는 질문 (FAQ)

- **Q: DB 연결이 필요한 코드는 어떻게 테스트하나요?**
  - A: AI에게 "DB 연결 부분은 Mocking 처리해서 순수 비즈니스 로직만 테스트해 줘"라고 상황(Context)에 추가해 보세요. 의존성 주입(DI) 구조라면 AI가 알아서 Mock 객체를 생성해 줍니다.
- **Q: AI가 작성한 테스트 코드를 100% 믿어도 되나요?**
  - A: 아니요. AI는 매우 훌륭한 초안을 작성하지만, 비즈니스 도메인의 독특한 룰까지 완벽히 이해하진 못할 수 있습니다. 생성된 테스트가 우리 서비스의 의도와 맞는지, 검증 어서션(Assertion)이 올바른지 반드시 한 번 더 눈으로 확인(Code Review)해야 합니다.

- **Q: 어떤 AI 모델을 사용하는 것이 가장 좋나요?**
  - A: 프로그래밍 논리와 테스트 프레임워크 이해도가 압도적으로 높은 **Claude 3.5 Sonnet**을 1순위로 추천합니다.

---

## 🧬 프롬프트 해부 (Why it works?)

1. **페르소나 지정 (Role):** '시니어 QA 엔지니어' 역할을 주어, 단순히 코드가 돌아가는지 확인하는 것을 넘어 '코드를 어떻게든 망가뜨려 보려는' QA 특유의 예외 탐색 마인드를 발동시킵니다.
2. **구조화된 지시 (Given-When-Then):** 테스트 코드의 표준인 BDD(Behavior-Driven Development) 패턴을 요구하여, 가독성 높고 유지보수하기 쉬운 결과물을 강제합니다.
3. **자율적 엣지 케이스 탐색:** 개발자가 미처 생각하지 못한 엣지 케이스를 "스스로 식별하라"고 지시함으로써, 테스트의 깊이와 코드 커버리지를 비약적으로 끌어올립니다.

---

## 📊 증명: Before & After

### ❌ Before (입력: 간단한 할인율 계산 로직)

```javascript
function calculateDiscount(price, discountRate) {
  if (discountRate < 0 || discountRate > 100) {
    throw new Error("할인율은 0에서 100 사이여야 합니다.");
  }
  return price - price * (discountRate / 100);
}
```

<br>

### ✅ After (결과)

```javascript
import { calculateDiscount } from "./discount";

describe("calculateDiscount 함수 단위 테스트", () => {
  // Given-When-Then: 정상적인 할인율 적용
  test("Happy Path: 10,000원 상품에 20% 할인이 적용되면 8,000원을 반환해야 한다", () => {
    // Given
    const price = 10000;
    const discountRate = 20;

    // When
    const result = calculateDiscount(price, discountRate);

    // Then
    expect(result).toBe(8000);
  });

  // Given-When-Then: 엣지 케이스 - 0% 할인 (무료 배송 등의 기본 혜택 적용 시)
  test("Edge Case: 0% 할인을 적용하면 원가가 그대로 반환되어야 한다", () => {
    expect(calculateDiscount(5000, 0)).toBe(5000);
  });

  // Given-When-Then: 엣지 케이스 - 100% 할인 (전액 무료 쿠폰 적용 시)
  test("Edge Case: 100% 할인을 적용하면 0원이 반환되어야 한다", () => {
    expect(calculateDiscount(5000, 100)).toBe(0);
  });

  // Given-When-Then: 예외 상황 - 유효하지 않은 할인율 (음수)
  test("Exception: 할인율이 음수일 경우 에러를 발생시켜야 한다", () => {
    expect(() => calculateDiscount(10000, -10)).toThrow(
      "할인율은 0에서 100 사이여야 합니다.",
    );
  });

  // Given-When-Then: 예외 상황 - 유효하지 않은 할인율 (100 초과)
  test("Exception: 할인율이 100을 초과할 경우 에러를 발생시켜야 한다", () => {
    expect(() => calculateDiscount(10000, 150)).toThrow(
      "할인율은 0에서 100 사이여야 합니다.",
    );
  });
});
```

---

## 🎯 결론

테스트 코드는 미래의 나와 내 동료들을 위한 든든한 보험입니다.
이제 AI라는 유능한 어시스턴트에게 보험 서류 작성을 맡기고, 당신은 제품의 가치를 높이는 창조적인 코딩에만 집중하세요. 칼퇴근은 덤입니다! 🍷
