---
layout: /src/layouts/Layout.astro
title: "AI 코드 리뷰어: 내 똥 코드를 실리콘밸리 스타일로 (Code Review)"
author: "ZZabbis"
date: "2026-02-08"
updatedDate: "2026-02-08"
category: "개발/코딩"
description: "시니어 개발자가 없어도 괜찮아. AI에게 코드 리뷰를 맡기고 클린 코드로 거듭나는 프롬프트."
tags: ["코드리뷰", "개발자", "클린코드", "리팩토링", "ChatGPT"]
---

# 💻 AI 코드 리뷰어: 내 똥 코드를 실리콘밸리 스타일로

- **🎯 추천 대상:** 사수 없이 고군분투하는 주니어 개발자, 레거시 스파게티 코드에 고통받는 유지보수 담당자
- **⏱️ 소요 시간:** 30분 → 1분 단축
- **🤖 추천 모델:** Claude 3.5 Sonnet (코드 맥락 파악 및 리팩토링 최강자)

- ⭐ **난이도:** ⭐☆☆☆☆
- ⚡️ **효과성:** ⭐⭐⭐⭐⭐
- 🚀 **활용도:** ⭐⭐⭐⭐⭐

> _"돌아가긴 하는데... 변수명이 `a`, `b`, `temp`라니... 3개월 뒤의 내가 봐도 욕할 것 같은 코드, 이대로 커밋하시겠습니까?"_

코드는 작성하는 시간보다 누군가에게 읽히는 시간이 훨씬 깁니다. 하지만 바쁜 사수나 팀장님께 매번 PR(Pull Request) 리뷰를 부탁하기는 눈치가 보이죠. 이제 지치지 않는 **AI 시니어 개발자**를 개인 멘토로 채용하세요. 당신의 코드를 무자비하게, 하지만 논리적이고 친절하게 뜯어고쳐 줄 겁니다.

---

## ⚡️ 3줄 요약 (TL;DR)

1. 바쁜 사수 눈치 보지 말고 AI에게 즉각적인 코드 리뷰를 요청하세요.
2. 단순한 버그 탐지를 넘어, 가독성과 효율성을 갖춘 클린 코드로 리팩토링합니다.
3. 구글 수석 엔지니어의 페르소나를 부여해 실리콘밸리 수준의 코드 퀄리티를 확보하세요.

---

## 🚀 해결책: "Code Reviewer Prompt"

### 🥉 Basic Version (기본형: 퀵 버그 헌터)

빠르게 에러를 잡고 잠재적 결함만 확인하고 싶을 때 사용하세요.

> **역할:** 너는 날카로운 시각을 가진 시니어 개발자야.
> **요청:** 아래 코드에서 에러가 발생할 수 있는 잠재적 버그나 논리적 오류를 찾아줘. 만약 완벽하다면 "LGTM(Looks Good To Me)"이라고 말해.
>
> **코드:**
>
> ```[언어명]
> [여기에 코드를 붙여넣으세요]
> ```

<br>

### 🥇 Pro Version (전문가형: 실리콘밸리 클린 코드 리팩토링)

변수명부터 아키텍처까지, 코드의 영혼까지 싹 뜯어고칠 때 사용하세요.

> **역할 (Role):** 너는 구글(Google)의 10년 차 수석 소프트웨어 엔지니어이자 'Clean Code'의 열렬한 신봉자야.
>
> **상황 (Context):**
>
> - 배경: 사내 프로젝트의 핵심 로직을 작성/유지보수하고 있음.
> - 목표: 기술 부채를 줄이고, 팀원 누구나 이해하기 쉬운 직관적이고 견고한 코드로 개선.
>
> **요청 (Task):**
> 아래 제공된 `[코드]`를 분석하고 다음 4가지 핵심 기준에 맞춰 엄격하게 리뷰 및 리팩토링해 줘.
>
> 1. **가독성 (Readability):** 변수명과 함수명을 의도가 명확히 드러나도록 직관적으로 변경해. (예: `d` -> `elapsedTimeInDays`)
> 2. **효율성 (Efficiency):** 불필요한 루프를 줄이거나 시간 복잡도(O)를 개선할 수 있는 더 나은 알고리즘, 배열 메서드 등을 제안해.
> 3. **안전성 (Safety):** Null 참조, 타입 에러, 예외 처리(Try-Catch)가 누락된 곳(Edge Cases)을 꼼꼼하게 방어해.
> 4. **주석 (Comments):** 로직이 복잡한 부분에는 '무엇을(What)'이 아니라 '왜(Why)' 이렇게 작성했는지 JSDoc/Docstring 형태로 주석을 달아줘.
>
> **출력 형식 (Format):**
>
> - **리뷰 요약:** 기존 코드의 치명적 문제점 핵심 3가지 (블릿 포인트)
> - **리팩토링 코드:** 완벽하게 개선된 전체 코드 (코드 블록)
> - **핵심 변경 사유:** 왜 이렇게 수정하는 것이 더 나은 아키텍처인지 2줄 이내로 요약.
>
> **제약사항 (Constraints):**
>
> - 언어의 최신 문법(Modern Syntax)을 활용할 것.
> - 확실하지 않은 라이브러리나 내장 함수는 지어내지 말 것. (환각 방지)
>
> **입력 (Input Code):**
>
> ```[언어명]
> [여기에 코드를 전체 붙여넣으세요]
> ```

---

## 💡 작성자 코멘트 (Insight)

단순히 "이 코드 고쳐줘"라고 하면 AI는 겉핥기식의 문법 수정만 해주는 경우가 많습니다. 하지만 '구글 수석 엔지니어'라는 구체적인 페르소나를 부여하고 가독성/효율성/안전성이라는 명확한 평가 잣대를 들이밀면, AI는 완전히 다른 차원의 아키텍처적 인사이트를 뱉어냅니다.

특히 얽히고설킨 레거시 코드를 파악해야 할 때, 먼저 Pro 프롬프트로 분석을 돌려보세요. 원저작자의 의도를 빠르게 파악하는 동시에 안전하게 리팩토링할 수 있는 뼈대를 잡는 데 엄청난 시간을 아낄 수 있습니다. 제가 실무에서 가장 의존하는 프롬프트 1순위입니다.

---

## 🙋 자주 묻는 질문 (FAQ)

- **Q: 회사 내부 코드를 AI 모델에 그대로 올려도 안전한가요?**
  - A: **절대 주의해야 합니다.** API 키, 사내 IP, 민감한 비즈니스 로직(DB 스키마 등)은 반드시 마스킹(Masking) 처리하거나 `[PRIVATE_DATA]` 등으로 치환한 후 프롬프트를 실행하세요. 엔터프라이즈 환경이라면 데이터 학습에 사용되지 않는 기업용 요금제(Team/Enterprise)나 API 모델을 사용하는 것을 강력히 권장합니다.

- **Q: AI가 짜준 코드를 그대로 복붙해서 배포해도 되나요?**
  - A: 안 됩니다. AI는 때때로 존재하지 않는 라이브러리 메서드를 호출하는 '할루시네이션(환각)'을 일으키거나, 복잡한 비즈니스 요구사항의 맥락을 오해할 수 있습니다. AI의 결과물은 강력한 초안이자 제안일 뿐, 최종 코드 리뷰와 테스트를 통한 검증은 온전히 개발자의 몫입니다.

- **Q: 코드가 너무 길어서 한 번에 분석이 잘 안 되는데 어떡하나요?**
  - A: 함수나 클래스 단위로 쪼개서 질문하세요. "이 `UserService` 클래스의 `authenticate` 메서드만 중점적으로 리뷰해 줘"라고 범위를 좁히면, AI가 컨텍스트를 잃지 않고 훨씬 더 퀄리티 높은 딥 다이브 리뷰를 제공합니다.

---

## 🧬 프롬프트 해부 (Why it works?)

1. **최상급 페르소나 주입 (Role Prompting):** '10년 차 수석 엔지니어'이자 '클린 코드 신봉자'라는 역할은 AI의 내부 가중치를 최적화된 베스트 프랙티스(디자인 패턴, 클린 코드 원칙) 쪽으로 강하게 유도합니다.
2. **다면적 평가 기준 (Multi-dimensional Constraints):** 코드를 '가독성', '효율성', '안전성' 3가지 차원으로 강제 분리 분석하게 만들어, 단순히 돌아가기만 하는 엉성한 코드 생성을 원천 차단합니다.
3. **출력 형식의 구조화 (Formatted Output):** 문제점 요약, 개선된 코드, 변경 사유를 명확히 나누어 출력하게 함으로써 리뷰 내용을 한눈에 파악할 수 있도록 UX를 극대화했습니다.

---

## 📊 증명: Before & After

단순한 명령어와 구조화된 프롬프트의 차이는 결과 코드의 퀄리티에서 명확하게 드러납니다. 변수명부터 방어 로직까지 완벽하게 개선됩니다.

### ❌ Before (스파게티 코드)

```javascript
function proc(d) {
  let res = [];
  for (let i = 0; i < d.length; i++) {
    if (d[i].s === 1) {
      res.push(d[i]);
    }
  }
  return res;
}
```

### ✅ After (클린 코드)

```javascript
/**
 * 활성 상태인 사용자 목록을 필터링하여 반환합니다.
 * @param {Array<Object>} users - 전체 사용자 데이터 배열
 * @param {number} users[].status - 사용자 상태 코드 (1: 활성 상태)
 * @returns {Array<Object>} 활성 사용자만 포함된 새로운 배열
 */
const getActiveUsers = (users) => {
  // 예외 처리: 유효하지 않은 입력 방어
  if (!Array.isArray(users)) return [];

  const ACTIVE_STATUS_CODE = 1;

  // O(N) 시간 복잡도를 유지하며, 선언적 방식(filter)을 사용하여 가독성을 극대화함.
  return users.filter((user) => user?.status === ACTIVE_STATUS_CODE);
};
```

---

## 🎯 결론

좋은 코드는 한 편의 잘 쓰인 산문과 같습니다. 누구나 읽기 편하고, 작성자의 의도가 투명하게 드러나야 하죠.
AI 리뷰어는 24시간 깨어있으며, 아무리 기초적인 질문을 100번 던져도 결코 한숨 쉬지 않습니다.

지금 바로 당신의 IDE에 잠들어 있는 냄새나는 레거시 코드를 던져보세요.
진정한 **"LGTM (Looks Good To Me)"**을 받는 그날까지! 🍷
