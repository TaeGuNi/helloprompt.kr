---
interface Props {
  variant?: "hero" | "compact";
}

const { variant = "hero" } = Astro.props;
---

<div class={`search-container ${variant}`}>
  <input
    type="text"
    id="search-input"
    class="search-input"
    placeholder={variant === "hero" ? "SEARCH INTELLIGENCE..." : "Search..."}
    autocomplete="off"
  />
  <div id="search-results" class="search-results"></div>
</div>

<style>
  /* Base Styles */
  .search-container {
    position: relative;
    z-index: 50;
  }

  .search-input {
    width: 100%;
    box-sizing: border-box;
    background: rgba(10, 15, 20, 0.8);
    border: 1px solid rgba(0, 243, 255, 0.5);
    border-radius: 12px;
    color: #fff;
    font-family: "Noto Sans KR", sans-serif;
    transition: all 0.2s ease;
    backdrop-filter: blur(10px);
  }

  .search-input:focus {
    outline: none;
    border-color: #00f3ff;
    box-shadow: 0 0 0 4px rgba(0, 243, 255, 0.1);
    background: rgba(10, 15, 20, 0.95);
  }

  /* Variant: Hero (Home) */
  .search-container.hero {
    width: 100%;
    max-width: 800px;
    margin: 40px auto 0;
  }
  .search-container.hero .search-input {
    padding: 16px 24px;
    font-size: 1rem;
    text-align: left;
  }
  .search-container.hero .search-input::placeholder {
    color: #666;
    text-align: center;
  }

  /* Variant: Compact (Header) */
  .search-container.compact {
    width: 200px;
    margin-right: 15px; /* Spacing */
  }
  .search-container.compact .search-input {
    padding: 6px 12px;
    font-size: 0.85rem;
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.5);
    border-color: rgba(0, 243, 255, 0.3);
  }
  .search-container.compact .search-input:focus {
    width: 300px; /* Expand on focus */
    position: absolute;
    right: 0;
    top: 0;
    z-index: 110;
    background: #0a0f14;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
  }

  /* Search Results Dropdown */
  .search-results {
    position: absolute;
    top: calc(100% + 10px);
    left: 0;
    right: 0;
    width: 100%;
    box-sizing: border-box;
    background: #0a0f14;
    border: 1px solid #333;
    border-radius: 12px;
    max-height: 400px;
    overflow-y: auto;
    z-index: 100;
    display: none;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  }

  /* Compact Results adjustments */
  .search-container.compact .search-results {
    width: 300px; /* Fixed width for compact results */
    right: 0;
    left: auto; /* Align to right */
    top: calc(100% + 5px);
  }

  /* Scrollbar */
  .search-results::-webkit-scrollbar {
    width: 6px;
  }
  .search-results::-webkit-scrollbar-thumb {
    background: #333;
    border-radius: 3px;
  }

  @media (max-width: 768px) {
    .search-container.compact {
      display: none; /* Hide on mobile for now, or make icon-only */
    }
  }
</style>

<style is:global>
  /* 검색 항목 (Global because created dynamically) */
  .search-item {
    display: block;
    padding: 16px 20px;
    border-bottom: 1px solid #1a1f25;
    text-decoration: none;
    transition: background 0.1s ease;
  }
  .search-item:last-child {
    border-bottom: none;
  }

  .search-item:hover {
    background: rgba(0, 243, 255, 0.05);
  }

  .search-item h4 {
    margin: 0 0 6px 0;
    color: #fff;
    font-size: 1rem;
    font-weight: 600;
    letter-spacing: -0.02em;
  }
  .search-item p {
    margin: 0;
    color: #999;
    font-size: 0.85rem;
    line-height: 1.5;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  /* Compact mode items styling overrides if needed */
  /* Since items are global, we might need specificity or just keep them same */
</style>

<script>
  import Fuse from "fuse.js";

  interface SearchItem {
    title: string;
    description: string;
    url: string;
    tags?: string[];
  }

  // Support multiple search inputs (though typically one per page)
  // We attach listener to the container's input
  const searchInputs = document.querySelectorAll(".search-input");

  // Fuse.js 인스턴스 (Singleton lazy load)
  let fuse: Fuse<SearchItem> | null = null;
  let isIndexLoaded = false;

  async function loadSearchIndex() {
    if (isIndexLoaded) return;
    try {
      const response = await fetch("/search.json");
      const searchIndex: SearchItem[] = await response.json();

      fuse = new Fuse(searchIndex, {
        keys: [
          { name: "title", weight: 0.6 },
          { name: "tags", weight: 0.3 },
          { name: "description", weight: 0.1 },
        ],
        threshold: 0.4,
        ignoreLocation: true,
        includeScore: true,
      });

      isIndexLoaded = true;
      console.log("Search Index Loaded");
    } catch (error) {
      console.error("Failed to load search index:", error);
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type
  function debounce(func: Function, delay: number) {
    let timeoutId: number;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (...args: any[]) => {
      clearTimeout(timeoutId);
      timeoutId = window.setTimeout(() => func(...args), delay);
    };
  }

  searchInputs.forEach((input) => {
    const inputEl = input as HTMLInputElement;
    const container = inputEl.closest(".search-container");
    const resultsContainer = container?.querySelector(
      ".search-results",
    ) as HTMLElement;

    if (!resultsContainer) return;

    // Load index on focus
    inputEl.addEventListener("focus", () => {
      loadSearchIndex();
    });

    const handleSearch = () => {
      const query = inputEl.value.trim();

      if (query.length < 1) {
        resultsContainer.style.display = "none";
        resultsContainer.innerHTML = "";
        return;
      }

      if (!fuse) return; // Not loaded yet

      const results = fuse.search(query);
      const matchedPosts = results.map((result) => result.item);

      renderResults(matchedPosts, resultsContainer);
    };

    inputEl.addEventListener("input", debounce(handleSearch, 300));

    // Close on outside click
    document.addEventListener("click", (event) => {
      const target = event.target as HTMLElement;
      if (!container?.contains(target)) {
        resultsContainer.style.display = "none";
        // Optional: Reset compact input width if needed via blur logic
      }
    });
  });

  function renderResults(posts: SearchItem[], container: HTMLElement) {
    container.innerHTML = "";
    container.style.display = "block";

    if (posts.length === 0) {
      container.innerHTML = `
        <div style="padding: 20px; color: #888; text-align: center; font-size: 0.9rem;">
            NO DATA FOUND
        </div>
      `;
      return;
    }

    const fragment = document.createDocumentFragment();
    const trackEvent = (action: string, params: Record<string, unknown>) => {
      // @ts-expect-error -- External script
      if (typeof window.gtag === "function") {
        // @ts-expect-error -- External script
        window.gtag("event", action, params);
      }
    };

    posts.forEach((post) => {
      const link = document.createElement("a");
      link.className = "search-item";
      link.href = post.url;
      link.innerHTML = `
        <h4>${post.title}</h4>
        <p>${post.description}</p>
      `;

      // [Analytics] Track Search Result Click
      link.addEventListener("click", () => {
        const query = (
          document.querySelector(".search-input") as HTMLInputElement
        )?.value;
        trackEvent("select_content", {
          content_type: "search_result",
          search_term: query,
          item_id: post.title,
        });
      });

      fragment.appendChild(link);
    });

    container.appendChild(fragment);
  }
</script>
