---
layout: /src/layouts/Layout.astro
title: "JSONだけ投げればTypeScript型定義がパッ！(feat. Zod)"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "コーディング/開発"
description: "複雑なJSONデータからTypeScriptの型定義とZodスキーマを一瞬で自動生成する実用的なプロンプトです。"
tags: ["TypeScript", "Zod", "JSON", "型定義", "生産性"]
---

# 📝 JSONだけ投げればTypeScript型定義がパッ！(feat. Zod)

- **🎯 推奨対象:** フロントエンドエンジニア、バックエンドエンジニア、フルスタック開発者
- **⏱️ 所要時間:** 30分 → 1分短縮
- **🤖 推奨モデル:** Claude 3.5 Sonnet, GPT-4o, Gemini 2.5 Pro

- ⭐ **難易度:** ⭐☆☆☆☆
- ⚡️ **効果性:** ⭐⭐⭐⭐⭐
- 🚀 **活用度:** ⭐⭐⭐⭐⭐

> _「APIのレスポンスが変わるたびに、ネストされたTypeScriptの型定義を手作業で修正するのに疲れていませんか？」_

`interface User { ... }` と、まだ一つずつ手打ちしていますか？
深くネストされたオブジェクト、配列の配列、予測不能なオプショナル値... 手作業での型定義はミスの温床であり、何より開発者の貴重な時間を奪います。
APIレスポンスのJSONをそのままコピーして投げるだけで、完璧なTypeScriptの型定義（Interface/Type）はもちろん、堅牢なランタイムバリデーションのためのZodスキーマまで全自動で生成する方法をご紹介します。

---

## ⚡️ 3行要約 (TL;DR)

1. **瞬時変換:** 複雑な生のJSONデータを、実用的なTypeScriptのInterface/Typeに即座に変換します。
2. **ランタイムの安全性:** コンパイル時の型定義だけでなく、実データのバリデーション用Zodスキーマも同時に生成します。
3. **高精度な推論:** ネストされた構造や、Null許容（Nullable/Optional）フィールドを自動で判別・分離してクリーンなコードを保ちます。

---

## 🚀 解決策：「TypeScript ＆ Zod 型定義マスター」

### 🥉 Basic Version (基本形)

細かい条件は気にせず、とにかく早く型定義のひな形が欲しい場合に使用してください。

> **役割:** あなたはTypeScriptに精通したシニアエンジニアです。
> **タスク:** 以下のJSONデータから、TypeScriptの型定義とZodスキーマを生成してください。
> **JSONデータ:**
> [ここにJSONデータを貼り付ける]

<br>

### 🥇 Pro Version (専門家形)

実務レベルでそのままコピペして使える、高品質で詳細なコードが必要な場合に使用してください。

> **役割 (Role):** あなたはTypeScriptエコシステムとデータモデリングに精通したシニアフロントエンドエンジニアです。
>
> **状況 (Context):**
>
> - 背景: バックエンドAPIから複雑なJSONレスポンスを受け取りました。これをクライアント側で安全に扱うための型定義が必要です。
> - 目標: コンパイル時の型チェックとランタイムのバリデーションを両立させる堅牢なコードを生成すること。
>
> **要件 (Task):**
>
> 1. 提供されたJSONデータに基づいて、**Zodスキーマ (`z.object` 等)** を作成してください。
> 2. 作成したZodスキーマから `z.infer` を使用して **TypeScriptの型（Type）** を推論・定義してください。
> 3. スキーマ名と型名はパスカルケース（PascalCase）を使用し、プレフィックスやサフィックスを適切に付与してください（例: `UserSchema`, `User`）。
>
> **JSONデータ:**
>
> `[ここにJSONデータを貼り付けてください]`
>
> **制約事項 (Constraints):**
>
> - 全てのフィールドは基本的に必須（`required`）として扱ってください。ただし、値に `null` が含まれる場合のみ `.nullable().optional()` として処理してください。
> - ネストされたオブジェクトや配列内のオブジェクトは、インラインで記述せず、独立したZodスキーマおよび型として分離して定義してください。
> - JSDocコメントを記述し、プロパティ名や値から推論される各フィールドの説明を丁寧に追加してください。
>
> **注意点 (Warning):**
>
> - 余計な解説は省き、そのままプロジェクトにコピーして使えるTypeScriptのコードブロックのみを出力してください。

---

## 💡 作成者コメント (Insight)

このプロンプトの真の価値は、「Type/Interfaceの生成」にとどまらず、「Zodスキーマの同時生成と分離」までを一手に担ってくれる点にあります。
実際の現場では、APIの仕様書（Swagger等）が古かったり、ドキュメントにない隠しフィールドが存在したりすることが多々あります。そんな時、Postmanやブラウザのネットワークタブから取得した生のJSONレスポンスをそのままこのプロンプトに投げるだけで、100%実データに基づいた型安全なフロントエンド環境を数秒で構築できます。
特に、ネストされたオブジェクトを自動で分離（例: `ContactSchema` と `UserSchema`）するよう指示しているため、コードの可読性と再利用性が劇的に向上します。

---

## 🙋 よくある質問 (FAQ)

- **Q: JSONデータに配列が含まれている場合、型はどうなりますか？**
  - A: プロンプト内で「配列内のオブジェクトも分離する」よう指示しているため、`Array<{...}>` のようなインライン定義ではなく、例えば `ItemSchema` を独立して作成した上で `z.array(ItemSchema)` のようにクリーンな構造で生成してくれます。

- **Q: Zodではなく、YupやValibotを使いたいのですが？**
  - A: プロンプト内の `Zod` および `z.infer` などのキーワードを `Yup` や `Valibot` の構文に置き換えるだけで、指定したバリデーションライブラリに合わせて正確にスキーマを生成してくれます。

- **Q: 数千行にも及ぶ巨大なJSONデータを投げても大丈夫ですか？**
  - A: AIモデルのトークン制限の範囲内であれば機能しますが、長すぎる場合は処理が途切れる可能性があります。その場合は、配列の中身を1〜2件に減らすなど、「データの構造」だけが伝わるようにJSONをダイエットさせてから投げると、より高速かつ正確に生成されます。

---

## 🧬 プロンプト解剖 (Why it works?)

1. **JSDocの強制付与:** AIにフィールドの意味を推論させJSDocを書かせることで、IDEでの開発体験（マウスホバー時のツールチップ表示）が格段に向上します。
2. **分離設計の指示 (Separation of Concerns):** ネストされたオブジェクトをインライン化させず強制的に分離させることで、変更に強く保守しやすいクリーンなコードが生成されます。
3. **Single Source of Truth (SSOT):** Interfaceを先に作るのではなく、「Zodスキーマを起点とし、そこから `z.infer` で型を推論する」という現代のTypeScriptのベストプラクティスをAIに強制しています。

---

## 📊 証明: Before & After

### ❌ Before (入力JSON)

```json
{
  "id": 1,
  "name": "Jay",
  "contact": {
    "email": "jay@test.com",
    "phone": null
  },
  "tags": ["developer", "admin"]
}
```

### ✅ After (出力結果)

```typescript
import { z } from "zod";

/**
 * 連絡先情報
 */
export const ContactSchema = z.object({
  /** メールアドレス */
  email: z.string().email(),
  /** 電話番号（未登録の場合はnull） */
  phone: z.string().nullable().optional(),
});
export type Contact = z.infer<typeof ContactSchema>;

/**
 * ユーザー情報
 */
export const UserSchema = z.object({
  /** ユーザー固有ID */
  id: z.number(),
  /** ユーザー名 */
  name: z.string(),
  /** ユーザーの連絡先情報 */
  contact: ContactSchema,
  /** 関連タグ一覧 */
  tags: z.array(z.string()),
});
export type User = z.infer<typeof UserSchema>;
```

---

## 🎯 結論

型定義はシステムを守る堅牢な安全装置ですが、それを作る退屈な作業で疲弊してしまっては本末転倒です。
このプロンプトを使って、コピペ一発で安全かつ頑丈な型システムを構築し、本来注力すべきビジネスロジックの実装に大切な時間を使いましょう！ 🍷
