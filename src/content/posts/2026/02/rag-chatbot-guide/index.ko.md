---
layout: /src/layouts/Layout.astro
title: "RAG(검색 증강 생성) 구축: 내 데이터로 똑똑한 챗봇 만들기"
author: "ZZabbis"
date: "2026-02-11"
updatedDate: "2026-02-11"
category: "AI/개발"
description: "ChatGPT가 모르는 우리 회사 사내 규정, 매뉴얼을 학습시키는 법. 랭체인(LangChain)과 벡터 DB로 RAG 파이프라인 구축하기."
tags: ["RAG", "LangChain", "벡터DB", "챗봇", "AI개발"]
---

# 🧠 RAG(검색 증강 생성) 구축: 내 데이터로 똑똑한 챗봇 만들기

- **🎯 추천 대상:** "우리 회사 규정 물어보면 헛소리하는 챗봇"에 지친 담당자, 사내 위키를 AI로 검색하고 싶은 개발자
- **⏱️ 소요 시간:** 30분 (파이프라인 구축)
- **🤖 추천 모델:** GPT-4o-mini (가성비) + OpenAI Embeddings

- ⭐ **난이도:** ⭐⭐⭐⭐☆
- ⚡️ **효과성:** ⭐⭐⭐⭐⭐
- 🚀 **활용도:** ⭐⭐⭐⭐⭐

> _"GPT는 똑똑한데, 왜 우리 회사 연차 규정은 모를까요?"_

당연합니다. 우리 회사의 규정을 학습하지 않았으니까요. 그렇다고 매번 모델을 파인튜닝(Fine-tuning) 하자니 막대한 비용과 시간이 감당이 안 됩니다.

이 문제에 대한 가장 완벽한 정답은 바로 **RAG(Retrieval-Augmented Generation, 검색 증강 생성)**입니다. "관련 문서를 검색(Retrieval)해서 프롬프트에 추가(Augmented)한 뒤, 답변을 생성(Generation)하게 하라." 이 직관적인 개념만 이해하면, 환각(Hallucination) 없이 우리 회사만의 완벽한 맞춤형 AI 챗봇을 단 30분 만에 구축할 수 있습니다.

---

## ⚡️ 3줄 요약 (TL;DR)

1. **임베딩(Embedding):** 텍스트 문서를 의미 단위로 쪼개어 숫자로 변환한 뒤, 벡터 DB(Pinecone, ChromaDB 등)에 저장합니다.
2. **검색(Retrieval):** 사용자의 질문이 들어오면, 벡터 DB에서 질문과 가장 의미가 유사한 문서를 찾아옵니다.
3. **생성(Generation):** 찾아온 문서를 프롬프트에 컨텍스트로 삽입하고, "이 내용을 바탕으로 대답해"라고 AI에게 지시합니다.

---

## 🚀 해결책: "RAG Architect Prompt"

### 🥉 Basic Version (기본형)

RAG의 전체적인 구조를 잡고 개념을 빠르게 익히고 싶을 때 사용하세요.

> **요청:**
> 사내 PDF 문서 100개를 기반으로 직원의 질문에 정확하게 답하는 사내용 챗봇을 만들고 싶어. LangChain을 프레임워크로 사용한다고 가정하고, 전체 데이터 흐름(Data Flow)을 왕초보도 이해할 수 있도록 단계별로 설명해 줘. 그리고 토이 프로젝트로 쓰기 좋은 무료 벡터 DB도 하나 추천해 줘.

<br>

### 🥇 Pro Version (전문가형)

실제 프로덕션 환경에서 작동하는 파이썬(Python) 기반의 파이프라인 코드가 즉시 필요할 때 사용하세요.

> **역할 (Role):** 너는 10년 차 시니어 AI 엔지니어링 전문가야.
>
> **상황 (Context):**
>
> - 배경: 사내 규정이 담긴 수백 개의 PDF 문서를 기반으로 답변하는 사내 헬프데스크 챗봇을 구축해야 해.
> - 목표: Hallucination(환각) 없이 오직 제공된 문서에 기반해서만 답변하는 견고한 RAG 파이프라인을 완성하는 것.
>
> **기술 스택 (Stack):** Python, LangChain, OpenAI API, ChromaDB
>
> **요청 (Task):**
> 다음 요구사항을 완벽하게 충족하는 RAG 파이프라인 코드를 작성해 줘.
>
> 1. **Document Loader:** `PyPDFLoader`를 사용하여 `./docs` 폴더 내의 모든 PDF 파일을 재귀적으로 읽어올 것.
> 2. **Text Splitter:** `RecursiveCharacterTextSplitter`를 사용하여 문서를 1000자 단위로 분할할 것. (문맥 단절 방지를 위해 `chunk_overlap`은 200자로 설정)
> 3. **Vectorstore:** `OpenAIEmbeddings`(`text-embedding-3-small` 모델)를 사용하여 로컬 `ChromaDB`에 벡터화하여 저장할 것.
> 4. **Retrieval Chain:** 질문이 입력되면 Vectorstore에서 유사도 검색(Similarity Search)을 수행하고, `RetrievalQA` 체인을 통해 최종 답변을 생성할 것.
>
> **제약사항 (Constraints):**
>
> - 출력 형식은 즉시 복사해서 실행할 수 있는 완성된 `.py` 스크립트 형태의 마크다운 코드 블록 하나로만 제공해.
> - 코드 내에 주석을 상세히 달아서 각 단계가 왜 필요한지 초보자도 이해할 수 있게 설명해 줘.
>
> **주의사항 (Warning):**
>
> - 프롬프트 템플릿 코드에 반드시 "제공된 [Context]에 없는 내용은 절대 지어내지 말고 모른다고 답변할 것"이라는 지시를 포함시켜야 해. (환각 억제 최우선)

---

## 💡 작성자 코멘트 (Insight)

RAG 파이프라인의 최종 답변 품질은 8할이 **'청크(Chunk) 사이즈'**와 **'임베딩 모델의 성능'**에서 결정됩니다.

문서를 너무 잘게 쪼개면 핵심 문맥(Context)이 끊어져 AI가 엉뚱한 소리를 하고, 반대로 너무 크게 쪼개면 토큰 낭비가 심해지고 핀포인트 답변의 정확도가 떨어집니다. 실무에서는 `RecursiveCharacterTextSplitter`를 사용할 때 `chunk_size`를 500~1000 사이로, `chunk_overlap`을 100~200 정도로 설정하는 것이 보편적인 최적화 시작점입니다.

또한, 표나 이미지가 많은 복잡한 사내 문서라면 단순 텍스트 분할을 넘어 마크다운 파싱이나 LlamaParse 같은 고급 문서 구조화 도구를 결합하는 것이 필수적입니다.

---

## 🙋 자주 묻는 질문 (FAQ)

- **Q: 한국어 문서도 검색이 잘 되나요?**
  - A: 네, 매우 잘 됩니다. OpenAI의 최신 `text-embedding-3-small` 혹은 `text-embedding-3-large` 모델은 다국어(한국어 포함) 임베딩 성능이 압도적입니다. 만약 국내 도메인에 특화된 극강의 성능을 원하신다면 Upstage의 Solar 임베딩 API를 고려해 보시는 것도 강력히 추천합니다.

- **Q: 회사 기밀문서를 OpenAI API로 보내도 안전한가요?**
  - A: API(유료)를 사용할 경우 정책상 사용자의 데이터를 모델 학습에 사용하지 않는다고 명시하고 있습니다. 하지만 사내 보안 규정이 극도로 엄격하다면, 로컬에서 구동 가능한 오픈소스 LLM(예: Llama 3, Qwen)과 로컬 임베딩 모델(예: BGE-m3)을 조합하여 완전한 폐쇄망(On-Premise) RAG를 구축해야 합니다.

- **Q: AI가 자꾸 문서에 없는 거짓말(할루시네이션)을 합니다.**
  - A: 강력한 프롬프트 엔지니어링으로 제어해야 합니다. `RetrievalQA` 체인에 들어가는 프롬프트 템플릿에 _"반드시 제공된 [Context] 에 기반해서만 답변하고, 내용이 없다면 '문서에서 찾을 수 없습니다'라고만 답해라."_ 라는 명확한 제약을 걸어주면 환각을 99% 이상 억제할 수 있습니다.

---

## 🧬 프롬프트 해부 (Why it works?)

1. **구체적 라이브러리와 클래스 명시:** 단순히 "코드를 짜줘"가 아니라 `PyPDFLoader`, `RecursiveCharacterTextSplitter`, `ChromaDB` 등 실제 현업에서 쓰이는 모듈을 콕 집어 지시했습니다. 이로 인해 AI가 낡은 방식이나 비효율적인 코드를 짜는 것을 원천 차단합니다.
2. **청크 사이즈와 오버랩 파라미터 강제:** 데이터 전처리의 핵심인 1000자 분할, 200자 중첩이라는 구체적인 수치를 제공함으로써 AI가 최적화된 코드를 즉각 도출하게 만듭니다.
3. **환각(Hallucination) 방지 프롬프트 내재화:** 제약사항에 챗봇의 치명적 약점인 거짓말을 통제하는 시스템 프롬프트 설정을 강제하여, 프로덕션 레벨에서도 바로 테스트해 볼 수 있는 안전한 코드를 얻어냅니다.

---

## 📊 증명: Before & After

### ❌ Before (일반 ChatGPT)

```text
Q: "우리 회사(Hello Inc.)의 2026년도 경조사비 지급 규정에 대해 알려줘."

A: "죄송합니다만, 저는 특정 기업(Hello Inc.)의 내부 사규나 실시간 경조사비
지급 규정에 대한 정보에 접근할 수 없습니다. 해당 내용은 소속 회사의 인사팀이나
사내 인트라넷을 확인해 보시기 바랍니다."
```

### ✅ After (RAG 적용 사내 챗봇)

```text
Q: "우리 회사(Hello Inc.)의 2026년도 경조사비 지급 규정에 대해 알려줘."

A: "[2026_사내규정_인사.pdf 기반 답변]
Hello Inc.의 2026년 규정에 따르면, 본인 결혼 시 축하금 100만 원과 화환이 지급됩니다.
지급 신청은 반드시 예식일 기준 1주일 전까지 사내 ERP 시스템을 통해 인사팀으로 접수해야 합니다."
```

---

## 🎯 결론

AI는 만능 천재가 아닙니다. 방대한 지식을 가졌지만, '우리 회사'의 사정은 하나도 모르는 똑똑한 신입사원과 같습니다.

하지만 이 신입사원에게 수백 쪽의 사규를 통째로 외우게 할 필요는 없습니다. 언제든 찾아볼 수 있도록 **"오픈북(Open Book)"** 환경만 만들어주면 됩니다. 그것이 바로 RAG 파이프라인의 본질입니다.

지금 당장 데스크톱에 잠들어 있는 PDF 매뉴얼들을 모아보세요. **당신이 가진 데이터가 곧, 당신만의 대체 불가능한 AI 지능이 됩니다.** 이제 직접 만들어 볼 시간입니다! 🍷
