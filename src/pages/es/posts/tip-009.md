---
layout: /src/layouts/Layout.astro
title: "Â¿Te da pereza escribir cÃ³digo de prueba? La IA lo hace por ti"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "Desarrollo"
description: "Un prompt que genera automÃ¡ticamente cÃ³digo de pruebas unitarias (Unit Test), considerando incluso los casos extremos (edge cases)."
tags: ["CÃ³digo de prueba", "TDD", "Jest", "JUnit"]
lang: es
---

# ğŸ“ Â¿Te da pereza escribir cÃ³digo de prueba? La IA lo hace por ti

> **ğŸ¯ Recomendado para:** Todos
> **â±ï¸ Tiempo requerido:** 5 minutos
> **ğŸ¤– Modelo recomendado:** Todos los modelos de IA

| Dificultad | Efectividad | Utilidad  |
| :--------: | :---------: | :-------: |
|  â­â­â˜†â˜†â˜†   | â­â­â­â­â­  | â­â­â­â­â˜† |

_"Â¿Ya estoy bastante ocupado implementando funciones y ahora tambiÃ©n cÃ³digo de prueba? Pero sin pruebas, cada despliegue es un mar de nervios."_

Para un servicio estable, las pruebas unitarias (Unit Test) son esenciales, pero escribirlas es un trabajo tedioso y que requiere mucho tiempo. Especialmente, es difÃ­cil cubrir todos los casos excepcionales (Edge Case). Deja esta tarea aburrida a la IA y concÃ©ntrate en la implementaciÃ³n de la lÃ³gica.

---

## âš¡ï¸ Resumen en 3 lÃ­neas (TL;DR)

1. Deja la tediosa redacciÃ³n de pruebas unitarias a la IA; ella se encargarÃ¡ incluso de los casos excepcionales.
2. Genera pruebas robustas considerando no solo el caso de Ã©xito (Happy Path) sino tambiÃ©n los casos lÃ­mite (Edge Cases).
3. Asigna el rol de ingeniero de QA para aumentar la cobertura de las pruebas y asegurar la estabilidad del cÃ³digo.

---

## ğŸš€ SoluciÃ³n: "GuardiÃ¡n de la Cobertura de Pruebas"

### ğŸ¥‰ VersiÃ³n BÃ¡sica

Ãšsala cuando necesites solo el resultado rÃ¡pidamente.

> **Rol:** Eres un `[lÃ­der de ingenierÃ­a de QA]`.
> **Solicitud:** Crea automÃ¡ticamente cÃ³digo de prueba unitaria (Unit Test) para esta funciÃ³n, considerando incluso los casos extremos.

<br>

### ğŸ¥‡ VersiÃ³n Pro

Ãšsala cuando necesites calidad detallada.

Copia el siguiente **PROMPT** y pÃ©galo en ChatGPT o Claude.

> **Rol (Role):** Eres un `[lÃ­der de ingenierÃ­a de QA]`.
>
> **Contexto (Context):** Debo escribir cÃ³digo de prueba unitaria para el `[funciÃ³n/clase]` que he creado. Usa el `[framework de pruebas que utilices]`.
>
> **Tarea (Task):**
>
> 1. Escribe una prueba para el caso de Ã©xito (Happy Path) con una entrada normal.
> 2. Identifica al menos 3 situaciones excepcionales o casos extremos (Edge Case) y escribe pruebas de fallo para ellos.
> 3. AÃ±ade comentarios en el cÃ³digo de prueba explicando quÃ© se estÃ¡ validando en cada caso.
>
> **CÃ³digo a probar:**
> `[Pega aquÃ­ tu cÃ³digo]`

---

## ğŸ§¬ AnatomÃ­a del Prompt (Â¿Por quÃ© funciona?)

---

## ğŸ“Š Prueba: Antes y DespuÃ©s

### âŒ Antes (Entrada: FunciÃ³n de cÃ¡lculo simple)

```javascript
function divide(a, b) {
  if (b === 0) throw new Error("No se puede dividir por 0.");
  return a / b;
}
```

<br>

### âœ… DespuÃ©s (Resultado)

```javascript
// Ejemplo usando el framework Jest

describe("Prueba de la funciÃ³n divide", () => {
  // 1. Happy Path: DivisiÃ³n normal
  test("deberÃ­a dar 5 al dividir 10 entre 2", () => {
    expect(divide(10, 2)).toBe(5);
  });

  // 2. Edge Case: DivisiÃ³n con nÃºmeros negativos
  test("deberÃ­a manejar correctamente los signos al dividir negativos", () => {
    expect(divide(-10, 2)).toBe(-5);
    expect(divide(-10, -2)).toBe(5);
  });

  // 3. Exception Case: DivisiÃ³n por 0
  test("deberÃ­a lanzar un error al dividir por 0", () => {
    expect(() => divide(10, 0)).toThrow("No se puede dividir por 0.");
  });

  // 4. Edge Case: Manejo de decimales
  test("deberÃ­a ser preciso cuando el resultado es un decimal", () => {
    expect(divide(5, 2)).toBe(2.5);
  });
});
```

---

## ğŸ¯ ConclusiÃ³n

El cÃ³digo de prueba es un seguro para mi 'yo' del futuro. Reduce drÃ¡sticamente la prima del seguro (tiempo de redacciÃ³n) a travÃ©s de la IA.
