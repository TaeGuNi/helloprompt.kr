---
layout: /src/layouts/Layout.astro
title: "내 코드의 시간 복잡도(Big O)는 얼마일까?"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "코딩/개발"
description: "작성한 알고리즘의 시간 복잡도와 공간 복잡도를 분석하고, 성능 개선 포인트를 찾아주는 프롬프트입니다."
tags: ["알고리즘", "시간복잡도", "Big-O", "성능최적화", "CS지식"]
lang: en
---

# 📝 내 코드의 시간 복잡도(Big O)는 얼마일까?

> **🎯 추천 대상:** 누구나
> **⏱️ 소요 시간:** 5분
> **🤖 추천 모델:** 모든 AI 모델

| 난이도  |   효과성   |  활용도   |
| :-----: | :--------: | :-------: |
| ⭐⭐☆☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐☆ |

_"for문이 두 개 겹쳐있는데... 이게 O(N)인가 O(N^2)인가?"_

코딩 테스트를 보거나 대용량 트래픽을 처리하는 로직을 짤 때, 시간 복잡도(Time Complexity) 분석은 필수입니다.
하지만 루프 안에 재귀 호출이 있거나 조건이 복잡해지면 계산하기 머리 아프시죠?
AI에게 코드를 보여주면 Big-O 표기법으로 정확하게 분석하고, 더 효율적인 알고리즘까지 제안해줍니다.

---

## ⚡️ 3줄 요약 (TL;DR)

1. 시간 복잡도 및 공간 복잡도 정확히 계산 (Big-O)
2. 성능 병목 구간(Bottleneck) 식별
3. 더 낮은 복잡도를 가진 개선된 알고리즘 제안

---

## 🚀 해결책: "복잡도 분석기"

### 🥉 Basic Version (기본형)

빠르게 결과만 필요할 때 사용하세요.

> **역할:** 너는 컴퓨터 과학(CS) 교수님이자 알고리즘 최적화 전문가야.
> **요청:** 작성한 알고리즘의 시간 복잡도와 공간 복잡도를 분석하고, 성능 개선 포인트를 찾아주는 프롬프트해줘.

<br>

### 🥇 Pro Version (전문가형)

디테일한 퀄리티가 필요할 때 사용하세요.

아래 **PROMPT** 내용을 복사해서 사용하세요.

> **역할 (Role):** 너는 컴퓨터 과학(CS) 교수님이자 알고리즘 최적화 전문가야.
>
> **상황 (Context):** 내가 작성한 알고리즘의 성능이 궁금해. 효율적인지, 아니면 개선이 필요한지 알고 싶어.
>
> **요청 (Task):**
>
> 1. 제공된 코드의 **시간 복잡도(Time Complexity)**와 **공간 복잡도(Space Complexity)**를 Big-O 표기법으로 분석해줘.
> 2. 왜 그런 복잡도가 나오는지 코드 라인별로 근거를 설명해줘.
> 3. 만약 더 효율적인 방법(예: O(N^2) -> O(N log N))이 있다면, 개선된 코드와 함께 설명해줘.
>
> **코드:**
>
> ```
> [여기에 분석할 코드를 붙여넣으세요]
> ```
>
> **제약사항 (Constraints):**
>
> - 최악의 경우(Worst Case)를 기준으로 분석해줘.
> - 입력 데이터의 크기(N)가 매우 클 때 발생할 수 있는 문제점을 언급해줘.

---

## 🧬 프롬프트 해부 (Why it works?)

---

## 📊 증명: Before & After

### ❌ Before (입력 코드)

```python
def find_duplicate(nums):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums[j]:
                return nums[i]
    return None
```

### ✅ After (결과)

**분석:**

- **시간 복잡도:** O(N^2). 이중 `for` 루프를 사용하고 있습니다. N이 10,000만 넘어도 매우 느려집니다.
- **공간 복잡도:** O(1). 추가적인 메모리를 거의 사용하지 않습니다.

**개선된 코드 (Hash Set 사용):**

```python
def find_duplicate_optimized(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None
```

**개선 결과:**

- **시간 복잡도:** O(N). 루프를 한 번만 돕니다.
- **공간 복잡도:** O(N). `seen` 집합에 데이터를 저장해야 합니다. (Time-Space Tradeoff)

---

## 🎯 결론

"돌아가니까 됐어"라는 생각은 이제 그만.
보이지 않는 성능까지 챙기는 개발자가 진짜 고수입니다. AI 교수님의 피드백으로 알고리즘 근육을 키워보세요! 🍷
