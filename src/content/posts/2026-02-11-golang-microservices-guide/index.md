---
layout: /src/layouts/Layout.astro
title: "Go(Golang) 마이크로서비스: 왜 배민과 당근은 Go로 갈아탔을까?"
author: "ZZabbis"
date: "2026-02-11"
updatedDate: "2026-02-11"
category: "백엔드/DB"
description: "Java/Spring 개발자를 위한 Go 언어 입문 가이드. 고루틴(Goroutine)의 강력함과 MSA에 최적화된 이유."
tags: ["Golang", "Go", "MSA", "백엔드", "마이크로서비스"]
---

# 🐹 Go(Golang) 마이크로서비스: 왜 배민과 당근은 Go로 갈아탔을까? {#golang}

- **🎯 추천 대상:** 무거운 Spring Boot 시동 시간에 지친 자바 개발자, MSA(Microservices) 도입을 고민하는 테크 리드
- **⏱️ 소요 시간:** 15분 (개념 이해 및 Hello World)
- **🤖 추천 모델:** Perplexity (최신 기술 스택 비교)

- ⭐ **난이도:** ⭐⭐⭐☆☆
- ⚡️ **효과성:** ⭐⭐⭐⭐⭐
- 🚀 **활용도:** ⭐⭐⭐⭐☆

> _"자바(Java)는 너무 무거워... 노드(Node.js)는 싱글 스레드라 불안하고..."_

이 고민의 끝에 **Go(Golang)**가 있습니다. 구글이 만든 언어답게 **"단순함"**과 **"성능"**에 몰빵했습니다. 배달의민족, 당근마켓, 토스 등 트래픽이 터지는 곳들이 왜 Go를 선택했는지, 코드로 확인해 보시죠.

---

## ⚡️ 3줄 요약 (TL;DR) {#tl-dr}

1.  **가볍다:** JVM 없이 기계어로 컴파일된다. (도커 이미지 10MB 가능)
2.  **빠르다:** 고루틴(Goroutine)으로 수만 개의 동시 접속을 껌처럼 처리한다.
3.  **쉽다:** 문법이 단순해서 자바 개발자라면 3일이면 배운다.

---

## 🚀 해결책: "Go Migration Guide"

### 🥉 Basic Version (Spring vs Go 비교) {#spring-vs-go}

개념 잡기.

> **질문:** "Spring Boot의 `@RestController`와 비슷한 걸 Go에서는 어떻게 구현해? `Gin`이나 `Echo` 프레임워크를 쓴 예제 코드를 보여줘."

<br>

### 🥇 Pro Version (동시성 처리 구현)

Go의 진가를 확인하는 시나리오.

> **역할 (Role):** 너는 고성능 백엔드 시스템 아키텍트야.
>
> **상황 (Context):**
>
> - **요구사항:** 외부 API 3개(회원 정보, 주문 내역, 배송 상태)를 동시에 호출해서 결과를 합쳐야 해.
> - **제약:** 자바에서는 `CompletableFuture`를 썼어. Go에서는 어떻게 해?
>
> **요청 (Task):**
>
> 1. **고루틴(Goroutine)**과 **채널(Channel)**을 사용해서 3개 API를 병렬로 호출하는 코드를 짜줘.
> 2. `WaitGroup`이나 `ErrGroup`을 써서 모든 요청이 끝날 때까지 기다리는 패턴을 보여줘.
> 3. 자바 코드와 비교해서 메모리 사용량이 얼마나 줄어들지 추정해줘.

---

## 💡 작성자 코멘트 (Insight) {#insight}

Go는 **"상속(Inheritance)"이 없습니다.**
자바 개발자들이 가장 당황하는 부분이죠. 대신 **"구성(Composition)"**과 **"인터페이스(Interface)"**를 씁니다.
"객체지향의 족쇄를 벗어던지니 이렇게 가벼울 수가!"라는 깨달음을 얻게 될 겁니다.

---

## 🙋 자주 묻는 질문 (FAQ) {#faq}

- **Q: 제네릭(Generic) 없지 않나요?**
  - A: Go 1.18부터 제네릭 들어왔습니다. 이제 `List<T>`처럼 쓸 수 있습니다.

- **Q: 예외 처리(Try-Catch)는요?**
  - A: Go는 예외가 아니라 **에러를 값(Value)으로 리턴**합니다. `if err != nil` 지옥에 오신 걸 환영합니다. (하지만 이게 훨씬 안전합니다.)

---

## 🧬 프롬프트 해부 (Why it works?) {#why-it-works}

1.  **동시성 패턴 요구:** Go의 알파이자 오메가는 동시성입니다. `Goroutine` 예제를 달라고 해야 Go를 쓰는 진짜 이유를 체감할 수 있습니다.
2.  **자바와의 비교:** 기존 지식(CompletableFuture)에 빗대어 설명해달라고 하면, 러닝 커브가 확 줄어듭니다.

---

## 📊 증명: Before & After

### ❌ Before (Spring Boot)

API 3개 호출 -> 스레드 풀 생성 -> 컨텍스트 스위칭 비용 발생 -> 메모리 500MB 점유 🐢

### ✅ After (Go)

API 3개 호출 -> 고루틴 3개 생성 (각 2KB) -> 스레드 1개에서 멀티플렉싱 -> 메모리 20MB 점유 🚀

---

## 🎯 결론 {#conclusion}

복잡한 프레임워크 뒤에 숨지 마세요.
Go는 날것(Raw)의 강력함을 줍니다.

당신의 서버가 다이어트할 시간입니다.
**"Go Gopher(고퍼)를 입양하세요."** 🍷
