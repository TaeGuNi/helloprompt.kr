---
layout: /src/layouts/Layout.astro
title: "私のコードの時間複雑度(Big O)はいくらだろう？"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "コーディング/開発"
description: "作成したアルゴリズムの時間計算量と空間計算量を分析し、パフォーマンス改善のポイントを見つけ出すプロンプトです。"
tags: ["アルゴリズム", "時間複雑度", "Big-O", "性能最適化", "CS知識"]
---

# 📝 私のコードの時間複雑度(Big O)はいくらだろう？

- **🎯 おすすめの対象:** すべての開発者、コーディングテストの準備者
- **⏱️ 所要時間:** 5分 → 1分に短縮
- **🤖 おすすめのモデル:** すべての対話型AI (ChatGPT, Claude, Geminiなど)

- ⭐ **難易度:** ⭐⭐☆☆☆
- ⚡️ **効果性:** ⭐⭐⭐⭐⭐
- 🚀 **活用度:** ⭐⭐⭐⭐☆

> _「二重のforループを書いちゃったけど…これってO(N)？それともO(N^2)？」_

コーディングテストを受けたり、大規模なトラフィックを処理するロジックを設計する際、時間計算量（Time Complexity）の分析は不可欠です。
しかし、ループの中に再帰呼び出しが隠れていたり、条件分岐が複雑になると、正確な計算量を割り出すのは頭の痛い作業ですよね。
AIにコードを読み込ませるだけで、Big-O記法を用いた正確な計算量分析から、より効率的なアルゴリズムの提案まで、一瞬で解決してくれます。

---

## ⚡️ 3行要約 (TL;DR)

1. コードの時間計算量と空間計算量をBig-O記法で正確に算出
2. パフォーマンス低下の原因となるボトルネック(Bottleneck)の特定
3. より計算量の低い、最適化されたアルゴリズムの代替案を提示

---

## 🚀 解決策：「計算量アナライザー」

### 🥉 Basic Version (基本形)

素早く結果だけを知りたい場合に使用してください。

> **役割:** あなたはコンピュータサイエンス(CS)の教授であり、アルゴリズム最適化の専門家です。
> **要求:** 私が作成したアルゴリズムの時間計算量と空間計算量を分析し、パフォーマンスの改善ポイントを見つけてください。

<br>

### 🥇 Pro Version (専門家形)

より詳細で精度の高い分析結果が必要な場合に使用してください。

> **役割 (Role):** あなたはコンピュータサイエンス(CS)の教授であり、アルゴリズム最適化の専門家です。
>
> **状況 (Context):**
>
> - 背景: 私が作成したアルゴリズムのパフォーマンスが気になっています。効率的に動作しているのか、それとも改善が必要なのかを知りたいです。
> - 目標: 正確な計算量の算出と、最適化されたコードの提案を受けること。
>
> **要求 (Task):**
>
> 1. 提供されたコードの**時間計算量(Time Complexity)**と**空間計算量(Space Complexity)**をBig-O記法で分析してください。
> 2. なぜその計算量になるのか、コードの行ごとに根拠を論理的に説明してください。
> 3. もし、より効率的なアプローチ（例: O(N^2) → O(N log N)）が存在する場合、改善されたコードとともにその原理を解説してください。
>
> **コード:**
>
> `[ここに分析したいコードを貼り付けてください]`
>
> **制約事項 (Constraints):**
>
> - 最悪のケース（Worst Case）を基準にして分析を行ってください。
> - 入力データのサイズ（N）が非常に大きい場合に発生しうる潜在的な問題点についても言及してください。
> - 出力形式は見やすいマークダウン形式でまとめてください。

---

## 💡 作成者のコメント (Insight)

このプロンプトは、単に計算量を尋ねるだけでなく、「行ごとの根拠」と「最悪のケースの想定」をAIに強いる点が強力です。実際の業務で、レビュアーから「このロジック、データ量が増えたらタイムアウトしませんか？」と指摘される前に、セルフチェックとして活用するのに最適です。特に、ハッシュマップを使ったTime-Space Tradeoff（時間と空間のトレードオフ）の提案などを引き出しやすくなり、エンジニアとしてのアルゴリズム的思考力を高める勉強ツールとしても非常に役立ちます。

---

## 🙋 よくある質問 (FAQ)

- **Q: 無料版のChatGPTやGeminiでも正確に分析できますか？**
  - A: はい、基本的な計算量の分析であれば無料版でも十分に可能です。ただし、数百行に及ぶ複雑なロジックや高度なアルゴリズムの場合は、Proバージョンのモデル（GPT-4やClaude 3.5 Sonnetなど）を使用することをおすすめします。

- **Q: どんなプログラミング言語でも対応していますか？**
  - A: Python、Java、C++、JavaScriptなど、主要なプログラミング言語にはすべて対応しています。AIは各言語固有の特性（例：Pythonのリスト内包表記の裏側の計算量など）も考慮して精密に分析してくれます。

---

## 🧬 プロンプト解剖 (Why it works?)

1. **CS教授というペルソナ:** AIに「教授」の役割を与えることで、単なる答え合わせではなく、学術的かつ論理的な根拠に基づいた丁寧な解説を引き出しています。
2. **最悪のケース(Worst Case)の強制:** 開発現場で最も重要な「最悪のシナリオでのパフォーマンス」を評価基準として明示することで、実務レベルで通用する厳しいコードレビューを実現しています。

---

## 📊 証明: Before & After

### ❌ Before (入力コード)

```python
def find_duplicate(nums):
    for i in range(len(nums)):
        for j in range(i + 1, len(nums)):
            if nums[i] == nums**[j]**:
                return nums[i]
    return None
```

### ✅ After (結果)

**分析:**

- **時間計算量:** `O(N^2)`。二重の `for` ループを使用しているため、入力サイズNが大きくなるにつれて実行時間が指数関数的に増加します。Nが10,000を超えると深刻なパフォーマンス低下を招きます。
- **空間計算量:** `O(1)`。追加のメモリやデータ構造を使用していないため、メモリ効率は高いです。

**改善されたコード (Hash Set の活用):**

```python
def find_duplicate_optimized(nums):
    seen = set()
    for num in nums:
        if num in seen:
            return num
        seen.add(num)
    return None
```

**改善結果:**

- **時間計算量:** `O(N)`。配列を一度だけスキャンするため、処理速度が劇的に向上します。
- **空間計算量:** `O(N)`。要素を保存するために `seen` というセット（集合）を使用するため、追加のメモリが必要になります。（Time-Space Tradeoff の適用）

---

## 🎯 結論

「とりあえず動けばいい」という考えはもう卒業しましょう。
目に見えないパフォーマンスの裏側にまで気を配れる開発者こそが、真のプロフェッショナルです。AI教授のフィードバックを活用して、アルゴリズムの筋肉を鍛え上げましょう！ 🍷
