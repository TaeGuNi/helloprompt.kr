---
layout: /src/layouts/Layout.astro
title: "肮脏代码，1 秒重构为整洁代码"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "编码/开发"
description: "将复杂的意大利面条代码转换为易读且易于维护的整洁代码的提示词。"
tags: ["重构", "整洁代码", "维护", "开发生产力"]
---

# 📝 肮脏代码，1 秒重构为整洁代码

- **🎯 推荐对象:** 后端开发者、前端开发者、以及所有深受遗留代码折磨的程序员
- **⏱️ 所需时间:** 5 分钟 → 1 分钟
- **🤖 推荐模型:** 所有对话型 AI (ChatGPT, Claude, Gemini 等)

- ⭐ **难度:** ⭐⭐☆☆☆
- ⚡️ **有效性:** ⭐⭐⭐⭐⭐
- 🚀 **实用性:** ⭐⭐⭐⭐☆

> _"连我自己都认不出我写的代码了…… 怎么解开这团乱麻？"_

由于赶进度而随意命名的变量、动辄超过百行的臃肿函数……这种经历想必每位开发者都不陌生。
如果有一位虚拟助手，能瞬间将那些连自己看着都觉得尴尬的“意大利面条代码”，按照**“整洁代码 (Clean Code)”**的黄金法则进行重构，会是怎样的体验？
只需这一个提示词，即可一步到位地提升代码的可读性、性能表现与可维护性。

---

## ⚡️ 3 行总结 (TL;DR)

1. 智能重命名变量与函数，瞬间提升代码直观性。
2. 消除冗余代码，精准拆分单一职责函数 (SRP)。
3. 无缝引入现代语法与性能优化最佳实践。

---

## 🚀 解决方案：“整洁代码重构器”

### 🥉 Basic Version (基础版)

当你只需要快速获取结果时使用。

> **角色:** 你是一位拥有 20 年经验的高级软件工程师兼“整洁代码 (Clean Code)”专家。
> **请求:** 请将以下复杂的“意大利面条代码”重构为易读、易维护的整洁代码。

<br>

### 🥇 Pro Version (专家版)

当你需要极致的代码质量与详细的重构说明时使用。

> **角色 (Role):** 你是一位拥有 20 年经验的高级软件工程师兼“整洁代码 (Clean Code)”专家。
>
> **情况 (Context):**
>
> - 背景: 我编写的代码虽然能够正常运行，但可读性极差，难以维护。变量命名含糊不清，且存在大量重复的逻辑。
> - 目标: 将其重构为符合现代行业标准、可读性强且易于扩展的代码。
>
> **请求 (Task):**
>
> 请严格按照以下标准重构我提供的代码：
>
> 1. **语义化命名:** 重新命名所有变量和函数，确保其名称能清晰准确地表达业务意图。
> 2. **函数拆分:** 将庞大的函数拆分为更小的单元，严格遵循单一职责原则 (SRP)。
> 3. **消除重复:** 识别并提取重复的逻辑，将其封装为独立的函数或工具类。
> 4. **针对性注释:** 仅在需要解释业务逻辑或复杂算法“为什么 (Why)”这么写的地方添加注释，避免无意义的“是什么 (What)”注释。
> 5. **现代化语法:** 运用该编程语言最新、最优雅的现代语法特性。
>
> **约束事项 (Constraints):**
>
> - 绝对禁止更改现有代码的业务逻辑或任何行为输出。
> - 请使用列表形式，清晰总结重构前后的核心变更点。
> - 请将最终输出分为“代码块”与“说明块”两部分进行展示。
>
> **代码输入 (Code):**
>
> `[请在此处粘贴需要重构的代码]`

---

## 💡 作者评论 (Insight)

这个提示词的精妙之处在于它不仅是一次简单的“代码格式化”，而是一次深度的“架构级洗礼”。在实际开发中，我们往往因为排期紧迫而妥协了代码质量，最终欠下高昂的技术债务。

特别是在接手遗留项目 (Legacy Code) 或是进行 Code Review 时，这个提示词能为你节省海量的时间。我强烈建议在使用时，明确告知 AI 当前项目所使用的语言和具体版本（例如 ES2023 或 Java 21），这样它能更精准地运用高级语法糖，产出的代码也会显得更加地道和专业。

---

## 🙋 常见问题 (FAQ)

- **Q: 重构后的代码真的可以直接复制到生产环境吗？**
  - A: 建议务必先运行现有的单元测试！虽然提示词中明确要求了“绝对禁止更改业务逻辑”，但 AI 偶尔会遗漏极为冷门的边缘情况。将其作为强大的重构草案，再进行人工校验是最佳实践。

- **Q: 如果我的代码有几千行，AI 能一次性处理完吗？**
  - A: 对于过长的代码，受限于大语言模型 (LLM) 的上下文窗口，可能会导致输出被截断或质量下降。建议按功能模块或单个类/函数为单位，分批次交由 AI 进行重构。

---

## 🧬 提示词解剖 (Why it works?)

1. **Role 设定:** 通过赋予“20 年经验高级工程师”的角色，强迫 AI 调取更高质量的编程规范和设计模式数据。
2. **Constraints 约束:** 强调“绝对禁止更改业务逻辑”，有效防止了 AI 在重构过程中擅自“炫技”导致原有功能被破坏，极大降低了幻觉 (Hallucination) 带来的风险。
3. **Task 结构化:** 明确了命名、拆分、消重、注释等 5 个维度的具体要求，引导 AI 像真正的高级工程师一样思考，避免了华而不实的表面修改。

---

## 📊 证明: Before & After

### ❌ Before (输入)

```javascript
function calc(d) {
  let t = 0;
  for (let i = 0; i < d.length; i++) {
    if (d[i].price > 100) {
      t += d[i].price * 0.9;
    } else {
      t += d[i].price;
    }
  }
  return t;
}
```

### ✅ After (结果)

```javascript
/**
 * 计算购物车内商品的总价。
 * 针对单价超过 100 的商品，自动应用 10% 的折扣。
 */
function calculateTotalPrice(items) {
  const DISCOUNT_THRESHOLD = 100;
  const DISCOUNT_RATE = 0.9;

  return items.reduce((total, item) => {
    const finalPrice =
      item.price > DISCOUNT_THRESHOLD ? item.price * DISCOUNT_RATE : item.price;

    return total + finalPrice;
  }, 0);
}
```

_核心变更：将难以理解的 `calc` 更名为 `calculateTotalPrice`，魔术数字（100, 0.9）被抽取为具名常量，并使用 `reduce` 替代了传统的 `for` 循环。_

---

## 🎯 结论

别再用“以后再重构”来欺骗自己了，我们都知道在软件工程里，“以后”往往意味着“绝不”。

有了这个强大的提示词，只需短短 3 秒钟，就能让散发着“坏味道”的代码焕发新生。现在，带着整洁优雅的代码，准时下班吧！🍷
