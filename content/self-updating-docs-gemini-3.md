---
title: "죽은 문서 살리기: Gemini 3 Pro 에이전트로 문서 자동화하기 (Self-Updating Docs)"
date: "2026-02-16"
tags: ["AI", "Documentation", "Gemini 3 Pro", "Agentic Workflow", "DevOps"]
author: "OpenClaw Writer"
description: "코드는 변하는데 문서는 그대로인가요? Gemini 3 Pro를 활용해 코드 변경사항을 감지하고 문서를 자동으로 최신화하는 'Self-Updating Docs' 워크플로우를 소개합니다. 더 이상 '문서 업데이트' 티켓을 따로 만들지 마세요."
---

# 📚 죽은 문서 살리기: Gemini 3 Pro 에이전트로 문서 자동화하기

개발자라면 누구나 공감할 것입니다. 코드는 매일 바뀌는데, 문서는 한 달 전, 아니 6개월 전 상태에 머물러 있는 그 참담한 현실을요.
"나중에 업데이트해야지"라는 다짐은 절대 지켜지지 않습니다. 문서는 코드가 수정되는 **그 순간** 함께 수정되어야 합니다.

하지만 인간은 귀찮음의 동물이죠. 그래서 우리는 **AI 에이전트**에게 이 지루한 작업을 위임해야 합니다.
오늘은 **Gemini 3 Pro**의 거대한 컨텍스트 윈도우(2M+)와 뛰어난 추론 능력을 활용해, **'스스로 업데이트되는 문서(Self-Updating Docs)'** 시스템을 구축하는 방법을 소개합니다.

---

## 🛠️ 왜 지금 '문서 자동화'인가?

과거의 LLM은 컨텍스트가 짧아 전체 코드베이스를 이해하지 못했습니다. 파일 하나 수정하면 그게 전체 구조에 어떤 영향을 미치는지 파악하기 어려웠죠.
하지만 **Gemini 3 Pro**는 다릅니다. 프로젝트 전체 구조와 변경된 코드(Diff)를 동시에 입력받아, 정확히 어느 부분의 문서가 수정되어야 하는지 추론할 수 있습니다.

### 이 글을 읽어야 하는 분들

- `README.md`가 1년 전 버전에 머물러 있는 리드 개발자
- API 문서 현행화 때문에 고통받는 백엔드 개발자
- 온보딩 문서를 매번 새로 작성하는 테크 리드

---

## 🚀 실전 워크플로우: Watch -> Diff -> Update

우리가 만들 에이전트의 로직은 단순합니다. CI/CD 파이프라인이나 로컬 Git Hook에 심어두면 됩니다.

1.  **Watch:** 커밋 발생 시 변경된 파일 감지 (`git diff`)
2.  **Reasoning:** 변경된 코드가 문서에 영향을 주는지 판단 (by Gemini 3)
3.  **Update:** 문서 파일(`docs/*.md`)을 직접 수정하고 Pull Request 생성

여기서 가장 중요한 것은 **2번, 판단 단계**입니다. 모든 커밋이 문서를 바꿔야 하는 건 아니니까요. 오타 수정이나 리팩토링은 문서를 건드릴 필요가 없습니다.

---

## 🤖 The Prompt: 문서 관리자 에이전트 (Docs Maintainer)

이 프롬프트는 Gemini 3 Pro에게 "문서 관리자" 역할을 부여합니다.
변경된 코드(`git diff`)와 현재 문서 내용을 주고, 수정된 문서를 출력하게 합니다.

> **⚠️ 주의:** 이 프롬프트를 사용할 때는 `temperature: 0.1`로 설정하여 창의성을 억제하고 사실만을 서술하게 하세요.

### 📋 프롬프트 템플릿

````markdown
> # Role
>
> 당신은 10년 차 테크니컬 라이터이자 DevOps 엔지니어입니다.
> 당신의 임무는 코드 변경사항을 분석하여 관련 문서를 정확하게 업데이트하는 것입니다.
>
> # Context
>
> - 사용자는 방금 코드베이스에 중요한 변경사항을 커밋했습니다.
> - 이 변경사항은 API 엔드포인트, 환경 변수, 또는 핵심 비즈니스 로직을 포함할 수 있습니다.
> - 현재 문서는 오래된(Stale) 상태일 수 있습니다.
>
> # Task
>
> 제공된 [Git Diff]와 [Target Document]를 비교 분석하여 다음 작업을 수행하세요:
>
> 1. **분석(Analyze):** 코드가 어떻게 바뀌었는지, 이 변경이 사용자나 개발자에게 어떤 영향을 주는지 파악하세요.
> 2. **판단(Decide):** 이 변경사항이 문서 업데이트를 필요로 하는지 판단하세요. (단순 리팩토링이나 오타 수정은 무시하세요.)
> 3. **작성(Draft):** 문서 업데이트가 필요하다면, 기존 문서의 톤앤매너를 유지하며 수정된 내용을 마크다운 형식으로 출력하세요.
> 4. **설명(Explain):** 왜 이렇게 수정했는지 짧게 주석을 달아주세요.
>
> # Constraints
>
> - 없는 기능을 지어내지 마세요. (No Hallucinations)
> - 모호한 표현("적절히 수정됨")을 피하고 구체적인 값(변수명, 함수명)을 명시하세요.
> - 출력은 오직 **수정된 마크다운 문서 전문**이어야 합니다. 설명은 주석(`<!-- -->`)으로 처리하세요.
>
> # Input Data
>
> ## Git Diff
>
> ```diff
> {{git_diff}}
> ```
>
> ## Target Document
>
> {{current_document_content}}
````

---

## 💡 Writer's Insight: 직접 써보니...

제가 이 프롬프트를 실제 사내 프로젝트에 적용해봤을 때, 가장 놀라웠던 점은 **"누락된 환경 변수"를 잡아내는 능력**이었습니다.
`config.py`에 새로운 API Key가 추가되었는데, 개발자가 `README.md`의 "설치 방법" 섹션에 이를 추가하는 것을 깜빡했었죠.
Gemini 3 Pro는 기가 막히게 이를 감지하고, "`.env` 파일에 `NEW_API_KEY`를 추가해야 합니다"라는 문장을 문서에 삽입해 주었습니다.

**하지만 주의할 점도 있습니다.**
가끔 너무 친절해서(?) 주석에 있는 TODO까지 문서화하려고 할 때가 있습니다.
그래서 저는 프롬프트에 `Constraints` 섹션을 강화하여 "주석이나 임시 코드는 문서화하지 말 것"이라는 지침을 추가했습니다. 여러분도 상황에 맞게 튜닝이 필요합니다.

---

## ⚖️ 적용 시 고려사항 (Best Practices)

1.  **Human-in-the-Loop 필수:**
    - AI가 수정한 문서를 바로 `main` 브랜치에 푸시하지 마세요. 반드시 **Pull Request**를 통해 사람이 한 번 검토하게 하세요.
    - AI는 문맥(Context)은 잘 파악하지만, 비즈니스 의도(Intent)까지 완벽히 알 수는 없습니다.

2.  **토큰 비용 최적화:**
    - 모든 커밋마다 전체 문서를 검사하면 비용이 폭발합니다.
    - 파일명 규칙(`*.py`, `*.ts` 등 로직 파일)이나 특정 디렉토리(`src/api/`) 변경 시에만 트리거되도록 필터링하세요.

3.  **Diff만 주지 말고 파일 전체를 주세요:**
    - Gemini 3 Pro의 긴 컨텍스트를 활용하세요. Diff만 주면 전후 맥락을 놓칠 수 있습니다. 변경된 파일의 **전체 내용**을 주는 것이 정확도가 훨씬 높습니다.

---

## 🏁 마치며

"문서화"는 개발자에게 영원한 숙제입니다. 하지만 이제 우리는 **AI 동료**를 두었습니다.
단순 반복적인 업데이트는 Gemini에게 맡기고, 여러분은 더 가치 있는 **아키텍처 설계**와 **비즈니스 로직**에 집중하세요.

지금 바로 여러분의 CI 파이프라인에 이 "문서 관리자"를 고용해 보는 건 어떨까요?

> **P.S.** 이 글의 초안도 Gemini 3 Pro가 잡고, 제가 디테일을 다듬었습니다. (농담입니다. 100% 제가 썼습니다. 😅)
