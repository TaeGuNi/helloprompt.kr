---
layout: /src/layouts/Layout.astro
title: "Refactorizar C√≥digo Sucio a C√≥digo Limpio en 1 Segundo"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "Codificaci√≥n/Desarrollo"
description: "Un prompt que transforma c√≥digo espagueti complejo en un c√≥digo limpio, f√°cil de leer y mantener."
tags: ["Refactorizaci√≥n", "C√≥digo Limpio", "Mantenimiento", "Productividad Dev"]
---

# üìù Refactorizar C√≥digo Sucio a C√≥digo Limpio en 1 Segundo

- **üéØ Recomendado para:** Desarrolladores Junior, Ingenieros de Software, L√≠deres T√©cnicos
- **‚è±Ô∏è Tiempo requerido:** 5 minutos ‚Üí Reducido a 1 minuto
- **ü§ñ Modelo recomendado:** Claude 3.5 Sonnet, GPT-4o, Gemini 1.5 Pro (Modelos avanzados de codificaci√≥n)

- ‚≠ê **Dificultad:** ‚≠ê‚≠ê‚òÜ‚òÜ‚òÜ
- ‚ö°Ô∏è **Efectividad:** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
- üöÄ **Utilidad:** ‚≠ê‚≠ê‚≠ê‚≠ê‚òÜ

> _"Ni siquiera puedo reconocer el c√≥digo que escrib√≠ hace un mes... ¬øC√≥mo desenredo este espagueti sin romper todo el sistema?"_

Todos hemos pasado por esto: variables con nombres incomprensibles creadas bajo la presi√≥n de una fecha de entrega, o funciones monol√≠ticas que superan las 100 l√≠neas y hacen de todo.
¬øQu√© pasar√≠a si tuvieras a un ingeniero senior a tu lado, listo para refactorizar ese c√≥digo del que te averg√ºenzas, llev√°ndolo a los m√°s estrictos **est√°ndares de 'Clean Code'**?
Con este prompt, puedes mejorar dr√°sticamente la legibilidad, el rendimiento y la mantenibilidad de tu c√≥digo en un abrir y cerrar de ojos, sin alterar su l√≥gica de negocio.

---

## ‚ö°Ô∏è Resumen en 3 l√≠neas (TL;DR)

1. **Renombrado Intuitivo:** Transforma variables cr√≠pticas en nombres descriptivos que revelan su intenci√≥n.
2. **Principio de Responsabilidad √önica (SRP):** Divide funciones gigantes en unidades peque√±as y testeables.
3. **Modernizaci√≥n de Sintaxis:** Actualiza c√≥digo heredado a los est√°ndares y mejores pr√°cticas de los lenguajes modernos.

---

## üöÄ La Soluci√≥n: "Refactorizador de C√≥digo Limpio"

### ü•â Versi√≥n B√°sica (Basic Version)

√ösala cuando necesites un arreglo r√°pido para un fragmento peque√±o de c√≥digo.

> **Rol:** Eres un Ingeniero de Software Senior experto en 'Clean Code'.
> **Solicitud:** Refactoriza el siguiente c√≥digo para que sea limpio, legible y f√°cil de mantener, sin cambiar su comportamiento.

<br>

### ü•á Versi√≥n Pro (Pro Version)

√ösala para refactorizaciones profundas y detalladas donde la calidad arquitect√≥nica es primordial.

> **Rol (Role):** Eres un Ingeniero de Software Senior con m√°s de 20 a√±os de experiencia y un purista del 'Clean Code' y los principios SOLID.
>
> **Contexto (Context):**
>
> - **Fondo:** El c√≥digo que escrib√≠ funciona y cumple con los requisitos, pero su legibilidad es p√©sima y es una pesadilla de mantener. Los nombres de las variables son oscuros y hay demasiada l√≥gica duplicada.
> - **Objetivo:** Transformar este c√≥digo espagueti en c√≥digo limpio, profesional y altamente mantenible.
>
> **Tarea (Task):**
> Refactoriza el c√≥digo proporcionado a continuaci√≥n siguiendo estrictamente estos criterios:
>
> 1. **Nomenclatura (Naming):** Cambia los nombres de variables y funciones para que revelen claramente su intenci√≥n.
> 2. **Separaci√≥n de Responsabilidades (SRP):** Divide las funciones monol√≠ticas en funciones m√°s peque√±as donde cada una haga exactamente una cosa.
> 3. **DRY (Don't Repeat Yourself):** Extrae cualquier l√≥gica repetida en funciones auxiliares o utilidades separadas.
> 4. **Comentarios Estrat√©gicos:** No comentes lo que hace el c√≥digo (el c√≥digo debe explicarse por s√≠ mismo). Agrega comentarios solo para explicar el 'Por qu√©' detr√°s de decisiones arquitect√≥nicas o de negocio complejas.
> 5. **Sintaxis Moderna:** Refactoriza utilizando las caracter√≠sticas y convenciones m√°s recientes y eficientes del lenguaje correspondiente.
>
> **C√≥digo a refactorizar:**
> [Pega tu c√≥digo aqu√≠]
>
> **Restricciones (Constraints):**
>
> - ¬°CR√çTICO! NO alteres en lo m√°s m√≠nimo la l√≥gica de negocio ni el resultado esperado del c√≥digo existente.
> - Proporciona una lista de vi√±etas resumiendo los principales cambios realizados (El "Antes y Despu√©s").
> - Presenta tu respuesta dividiendo claramente la secci√≥n de explicaci√≥n y el bloque de c√≥digo final.

---

## üí° Comentario del Autor (Insight)

La verdadera magia de este prompt radica en la restricci√≥n: _"NO alteres la l√≥gica de negocio"_. Al delegar la refactorizaci√≥n a la IA, el mayor miedo de un desarrollador es que el c√≥digo deje de funcionar. He utilizado este prompt innumerables veces para "limpiar la casa" antes de abrir un Pull Request. Funciona de manera excepcional con modelos como Claude 3.5 Sonnet, que tienen una comprensi√≥n del contexto de c√≥digo superior. **Un consejo profesional:** si tienes pruebas unitarias (Unit Tests) escritas para el c√≥digo original, adj√∫ntalas tambi√©n en el prompt. La IA las usar√° como garant√≠a para asegurar que la refactorizaci√≥n no rompa absolutamente nada.

---

## üôã Preguntas Frecuentes (FAQ)

- **Q: ¬øLa IA podr√≠a introducir errores sutiles o cambiar el comportamiento de mi c√≥digo?**
  - A: Aunque el prompt proh√≠be expl√≠citamente cambiar la l√≥gica, siempre existe un riesgo m√≠nimo. Es fundamental que **nunca conf√≠es ciegamente** en el c√≥digo generado. Revisa siempre el _diff_ y aseg√∫rate de ejecutar tus pruebas antes de integrar los cambios.

- **Q: ¬øFunciona esto para cualquier lenguaje de programaci√≥n?**
  - A: ¬°S√≠! Modelos como GPT-4 y Claude son pol√≠glotas. Ya sea que uses JavaScript, Python, Go, Java o Rust, la IA aplicar√° las convenciones idiom√°ticas espec√≠ficas del lenguaje (como `snake_case` en Python o `camelCase` en JS).

- **Q: ¬øQu√© pasa si mi c√≥digo depende de bibliotecas externas espec√≠ficas?**
  - A: Si tu c√≥digo usa hooks de React o m√©todos de Lodash, menci√≥nalo en el `Contexto` del prompt (ej. "Este c√≥digo usa React 18 y TailwindCSS"). La IA adaptar√° la refactorizaci√≥n utilizando las mejores pr√°cticas de esas herramientas.

---

## üß¨ Anatom√≠a del Prompt (Why it works?)

1. **Definici√≥n del Purista (Role):** Al especificar "purista de Clean Code y principios SOLID", obligamos a la IA a no solo hacer que el c√≥digo "se vea bonito", sino a reestructurarlo arquitect√≥nicamente.
2. **Reglas de Comentarios (Task 4):** Evita que la IA llene el c√≥digo con comentarios in√∫tiles como `// Itera sobre el array`, forzando un c√≥digo auto-documentado.
3. **Restricci√≥n de Seguridad (Constraints):** La instrucci√≥n "¬°CR√çTICO! NO alteres la l√≥gica de negocio" act√∫a como una barrera de seguridad (guardrail) vital contra las alucinaciones de la IA.

---

## üìä Prueba: Before & After

### ‚ùå Before (Entrada)

```javascript
function calc(d) {
  let t = 0;
  for (let i = 0; i < d.length; i++) {
    if (d[i].price > 100) {
      t += d[i].price * 0.9;
    } else {
      t += d[i].price;
    }
  }
  return t;
}
```

### ‚úÖ After (Resultado)

```javascript
/**
 * Calcula el monto total del carrito de compras.
 * NOTA: Por regla de negocio, los art√≠culos de m√°s de $100 reciben un descuento del 10%.
 */
function calculateTotalPrice(items) {
  const DISCOUNT_THRESHOLD = 100;
  const DISCOUNT_RATE = 0.9;

  return items.reduce((total, item) => {
    const isEligibleForDiscount = item.price > DISCOUNT_THRESHOLD;
    const finalPrice = isEligibleForDiscount
      ? item.price * DISCOUNT_RATE
      : item.price;

    return total + finalPrice;
  }, 0);
}
```

_Cambios aplicados: `calc` ‚Üí `calculateTotalPrice`, variables oscuras `d` ‚Üí `items`, eliminaci√≥n de n√∫meros m√°gicos mediante constantes, y transici√≥n de un bucle `for` imperativo a un m√©todo funcional `reduce`._

---

## üéØ Conclusi√≥n

No pospongas la deuda t√©cnica diciendo "Lo arreglar√© m√°s tarde".
Con este prompt, puedes transformar ese c√≥digo maloliente en una obra de arte profesional en cuesti√≥n de segundos. ¬°Refactoriza sin miedo, aprueba tus revisiones de c√≥digo (Code Reviews) a la primera y vete a casa temprano! üç∑
