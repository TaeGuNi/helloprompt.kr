---
title: "Modernizing Legacy Code (Spanish)"
description: "CÃ³mo la Inteligencia Artificial rescata a los desarrolladores de la deuda tÃ©cnica."
date: "2026-02-15"
image: "https://picsum.photos/seed/legacy/800/600"
tags: ["AI", "Tech", "legacy-code-ai"]
---

# ğŸ“ ModernizaciÃ³n de CÃ³digo Legacy con IA

- **ğŸ¯ PÃºblico objetivo:** Desarrolladores de Software, LÃ­deres TÃ©cnicos, Arquitectos
- **â±ï¸ Tiempo ahorrado:** de 4 horas â†’ a 5 minutos
- **ğŸ¤– Modelo recomendado:** Claude 3.5 Sonnet, GPT-4o, Gemini 2.5 Pro

- â­ **Dificultad:** â­â­â­â˜†â˜†
- âš¡ï¸ **Efectividad:** â­â­â­â­â­
- ğŸš€ **Utilidad:** â­â­â­â­â­

> _"Ese cÃ³digo espagueti de hace 5 aÃ±os que nadie se atreve a tocar... hoy la IA lo refactoriza, lo documenta y le escribe tests en menos de lo que tardas en prepararte un cafÃ©."_

Enfrentarse a un sistema _legacy_ sin documentaciÃ³n es una de las tareas mÃ¡s temidas por cualquier desarrollador. El miedo a romper una funcionalidad crÃ­tica en producciÃ³n paraliza la innovaciÃ³n y acumula una deuda tÃ©cnica asfixiante. Pero, Â¿y si tuvieras a un ingeniero senior incansable dispuesto a analizar, explicar y modernizar lÃ­nea por lÃ­nea sin quejarse?

---

## âš¡ï¸ Resumen en 3 lÃ­neas (TL;DR)

1. **AnÃ¡lisis profundo:** La IA desglosa funciones obsoletas y explica su lÃ³gica oculta paso a paso.
2. **RefactorizaciÃ³n segura:** Transforma cÃ³digo desactualizado en arquitecturas modernas (ej. migrar de _callbacks_ a _async/await_).
3. **Cobertura automÃ¡tica:** Genera pruebas unitarias (Unit Tests) instantÃ¡neas para garantizar que la nueva versiÃ³n funcione exactamente igual que la antigua.

---

## ğŸš€ SoluciÃ³n: Prompt "Rescate de CÃ³digo Legacy"

### ğŸ¥‰ VersiÃ³n BÃ¡sica (Basic Version)

Ãšsala cuando necesites una refactorizaciÃ³n rÃ¡pida para una sola funciÃ³n y sin muchas dependencias.

> **Rol:** Eres un Ingeniero de Software Senior experto en refactorizaciÃ³n.
> **Tarea:** Explica quÃ© hace este cÃ³digo y reescrÃ­belo usando buenas prÃ¡cticas modernas (Clean Code, principios SOLID).
> **CÃ³digo:** `[Pega tu cÃ³digo legacy aquÃ­]`

<br>

### ğŸ¥‡ VersiÃ³n Profesional (Pro Version)

Ãšsala para mÃ³dulos crÃ­ticos de negocio donde el riesgo de romper algo es alto. Requiere un control total sobre el resultado.

> **Rol (Role):** Eres un Arquitecto de Software Principal especializado en modernizaciÃ³n de sistemas _legacy_ y mitigaciÃ³n de deuda tÃ©cnica.
>
> **Contexto (Context):**
>
> - Fondo: Estoy trabajando con un cÃ³digo base de hace mÃ¡s de 5 aÃ±os. No hay documentaciÃ³n y el autor original ya no estÃ¡ en la empresa.
> - Objetivo: Necesito refactorizar el siguiente bloque de cÃ³digo para que sea altamente legible, mantenible y siga los estÃ¡ndares actuales, **sin alterar su comportamiento original**.
>
> **Tarea (Task):**
>
> 1. **AnÃ¡lisis:** Explica brevemente, paso a paso, la lÃ³gica de negocio actual que intenta resolver este cÃ³digo.
> 2. **RefactorizaciÃ³n:** Reescribe el cÃ³digo utilizando `[Lenguaje de programaciÃ³n y/o Framework objetivo, ej: TypeScript con async/await]`.
> 3. **Pruebas (Testing):** Escribe al menos 3 pruebas unitarias (casos de Ã©xito y casos lÃ­mite) usando `[Framework de testing, ej: Jest]` para verificar que la nueva versiÃ³n produce los mismos resultados que la antigua.
> 4. El cÃ³digo a evaluar es el siguiente:
>
> `[Pega tu cÃ³digo legacy aquÃ­]`
>
> **Restricciones (Constraints):**
>
> - No agregues nuevas funcionalidades bajo ninguna circunstancia. La refactorizaciÃ³n debe ser estrictamente estructural.
> - MantÃ©n el formato de salida en Markdown, separando claramente la explicaciÃ³n, el cÃ³digo refactorizado y los tests en bloques de cÃ³digo.
> - AsegÃºrate de extraer "variables mÃ¡gicas" o "nÃºmeros mÃ¡gicos" a constantes bien nombradas.
>
> **Advertencia (Warning):**
>
> - Si identificas un error grave en la lÃ³gica original (un bug histÃ³rico), no lo corrijas automÃ¡ticamente; en su lugar, adviÃ©rteme sobre Ã©l en una secciÃ³n final llamada "Riesgos Detectados".

---

## ğŸ’¡ Comentario del Autor (Insight)

Este prompt es un "salvavidas" absoluto en el dÃ­a a dÃ­a. La verdadera magia de la VersiÃ³n Pro no es solo que te devuelva un cÃ³digo estÃ©ticamente mÃ¡s limpio, sino que la restricciÃ³n de **no alterar la funcionalidad original** y la exigencia de generar **pruebas unitarias** reducen drÃ¡sticamente la ansiedad a la hora de desplegar a producciÃ³n.

Recomiendo encarecidamente usar modelos con ventanas de contexto amplias (como Claude 3.5 Sonnet o Gemini 2.5 Pro) para poder enviarle el archivo completo junto con otras clases de las que dependa. Â¡VerÃ¡s cÃ³mo entiende el contexto global de tu aplicaciÃ³n!

---

## ğŸ™‹ Preguntas Frecuentes (FAQ)

- **P: Â¿Puedo usar este prompt para migrar un script de un lenguaje a otro (ej. de PHP a Python)?**
  - A: Â¡SÃ­, absolutamente! Solo debes ajustar la instrucciÃ³n en la Tarea 2 para especificar el lenguaje de origen y el de destino. La IA adaptarÃ¡ los paradigmas (de orientado a objetos a funcional, por ejemplo) de manera excelente.

- **P: El cÃ³digo generado falla porque utiliza una librerÃ­a que no tengo instalada. Â¿QuÃ© hago?**
  - A: Esto sucede porque la IA suele asumir que tienes acceso a las herramientas estÃ¡ndar mÃ¡s modernas. Simplemente respÃ³ndele en el mismo chat: _"En mi proyecto no podemos instalar [Nombre de la LibrerÃ­a], por favor refactorÃ­zalo usando Ãºnicamente funciones nativas"_, y lo ajustarÃ¡ al instante.

---

## ğŸ§¬ AnatomÃ­a del Prompt (Â¿Por quÃ© funciona?)

1.  **PreservaciÃ³n del Comportamiento (Constraint):** Exigir explÃ­citamente que "no se agreguen nuevas funcionalidades" evita que la IA se ponga demasiado creativa e invente una lÃ³gica que no existÃ­a.
2.  **ValidaciÃ³n Integrada (Testing):** Al pedir pruebas unitarias dentro del mismo prompt, estamos forzando a la IA a verificar matemÃ¡ticamente su propia refactorizaciÃ³n.
3.  **Control de DaÃ±os (Warning):** La instrucciÃ³n de reportar errores histÃ³ricos en lugar de "arreglarlos en silencio" nos permite tomar decisiones de negocio conscientes antes de modificar el cÃ³digo.

---

## ğŸ“Š DemostraciÃ³n: Antes y DespuÃ©s

### âŒ Antes (CÃ³digo Legacy JavaScript)

```javascript
function calc(a, b, t) {
  var res = 0;
  if (t == 1) {
    res = a + b;
  } else if (t == 2) {
    res = a - b;
  } else {
    res = a * b;
  }
  // no tocar este log, negocio lo necesita
  setTimeout(function () {
    console.log(res);
  }, 1000);
  return res;
}
```

### âœ… DespuÃ©s (Refactorizado con IA a TypeScript)

```typescript
enum OperationType {
  ADD = 1,
  SUBTRACT = 2,
  MULTIPLY = 3,
}

/**
 * Calcula el resultado de una operaciÃ³n matemÃ¡tica bÃ¡sica.
 * Nota: Retiene el log asÃ­ncrono original para mantener la paridad de comportamiento.
 */
export const calculateOperation = (
  valueA: number,
  valueB: number,
  operationType: OperationType,
): number => {
  let result: number;

  switch (operationType) {
    case OperationType.ADD:
      result = valueA + valueB;
      break;
    case OperationType.SUBTRACT:
      result = valueA - valueB;
      break;
    default:
      // Por defecto actÃºa como multiplicaciÃ³n (OperationType.MULTIPLY)
      result = valueA * valueB;
  }

  // Se mantiene el delay asÃ­ncrono original requerido por negocio
  setTimeout(() => {
    console.info(`Resultado de la operaciÃ³n: ${result}`);
  }, 1000);

  return result;
};
```

---

## ğŸ¯ ConclusiÃ³n

Lidiar con cÃ³digo heredado ya no tiene que ser un castigo. Con el enfoque correcto y un prompt estructurado como el de un ingeniero principal, puedes transformar esas "cajas negras" a las que todos temen en cÃ³digo limpio, escalable y moderno en cuestiÃ³n de minutos.

Â¡Refactoriza con confianza y sal a tu hora de la oficina hoy! ğŸ·
