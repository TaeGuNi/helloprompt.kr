---
layout: ../../layouts/Layout.astro
title: "慢吞吞的SQL查询，3秒调优的秘诀"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "编程/开发"
description: "分析复杂且低效的SQL查询，优化性能并推荐索引的提示词。"
tags: ["SQL", "DB调优", "查询优化", "数据库"]
---

# 📝 慢吞吞的SQL查询，3秒调优的秘诀

> **🎯 推荐对象:** 所有人
> **⏱️ 所需时间:** 5分钟
> **🤖 推荐模型:** 所有AI模型

|  难度   |   有效性   |  实用性   |
| :-----: | :--------: | :-------: |
| ⭐⭐☆☆☆ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐☆ |

_"数据稍微积攒一点，查询就要花5秒..."_

起初很快的查询，随着数据增加变成了乌龟。
看了执行计划(Explain Plan)也是两眼一抹黑，很茫然吧？
给AI看查询，它会找出低效的部分，并进行像魔法一样的索引推荐。

---

## ⚡️ 3行摘要 (TL;DR)

1. 改善低效的连接(Join)和子查询
2. 推荐必要的索引(Index)
3. 用可读性好的Modern SQL语法重写

---

---

## 🚀 解决方案: "SQL查询调优器"

### 🥉 Basic Version (基础版)

当只需要快速获得结果时使用。

> **角色:** 你是20年经验的首席DBA(Database Administrator)兼SQL调优专家。
> **请求:** 请分析复杂且低效的SQL查询，优化性能并推荐索引。

<br>

### 🥇 Pro Version (专家版)

当需要细节质量时使用。

请复制下方 **PROMPT** 内容并使用。

> **角色 (Role):** 你是20年经验的首席DBA(Database Administrator)兼SQL调优专家。
>
> **情况 (Context):** 我应用程序中使用的SQL查询随着数据量变大，正在引起性能下降。
>
> **请求 (Task):**
> 请分析下面提供的SQL查询，执行以下作业:
>
> 1. **诊断问题:** 指出当前查询中可能引发性能下降的部分(Full Table Scan等)。
> 2. **查询优化:** 重新编写返回相同结果但运行更高效的查询。
> 3. **索引推荐:** 为了最大化查询性能，请用 `CREATE INDEX` 语句建议应该在哪些列上建立索引。
>
> **使用中的DB:** `[MySQL / PostgreSQL / Oracle / MS-SQL]`
>
> **对象查询:**
>
> ```sql
> [在此粘贴慢的查询]
> ```
>
> **约束事项 (Constraints):**
>
> - 现有查询的结果数据集绝对不能变更。
> - 请简单解释为什么变快了的运行原理。

---

---

---

## 🧬 提示词解剖 (Why it works?)

---

## 📊 证明: Before & After

### ❌ Before (输入查询)

```sql
SELECT * FROM users
WHERE id IN (SELECT user_id FROM orders WHERE price > 10000);
```

_问题: 子查询可能每行都执行(Dependent Subquery)._

### ✅ After (结果)

**优化的查询 (使用 JOIN):**

```sql
SELECT DISTINCT u.*
FROM users u
INNER JOIN orders o ON u.id = o.user_id
WHERE o.price > 10000;
```

**推荐索引:**

```sql
CREATE INDEX idx_orders_price_userid ON orders(price, user_id);
```

_说明: 将子查询更改为JOIN以进行优化，并创建复合索引以便先用 `price` 过滤再用 `user_id` 连接。_

---

---

---

## 🎯 结论

虽然有"调优是艺术"这句话，但现在是可以获得AI帮助的'科学'。
别因为慢查询受苦，接受AI DBA的免费咨询吧！ 🍷
