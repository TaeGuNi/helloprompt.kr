---
layout: /src/layouts/Layout.astro
title: "Mein Code ist MÃ¼ll! Clean Code Refactoring Coach"
author: "Zzabbis"
date: "2026-02-07T09:10:33.120Z"
updatedDate: "2026-02-07T09:10:33.120Z"
category: "Coding/IT"
description: "Ein Prompt, der unsauberen, gerade so funktionierenden Code in sauberen, leicht lesbaren und gut wartbaren Code verwandelt."
tags: ["Refactoring", "Clean Code", "Entwickler", "Code Review"]
---

# ğŸ“ Mein Code ist MÃ¼ll! Clean Code Refactoring Coach

- **ğŸ¯ Empfohlen fÃ¼r:** Softwareentwickler, Junior-Entwickler, Code-Reviewer
- **â±ï¸ Dauer:** 30 Minuten â†’ auf 1 Minute verkÃ¼rzt
- **ğŸ¤– Empfohlenes Modell:** Alle modernen KI-Modelle (ChatGPT, Claude, Gemini)

- â­ **Schwierigkeit:** â­â­â˜†â˜†â˜†
- âš¡ï¸ **EffektivitÃ¤t:** â­â­â­â­â­
- ğŸš€ **NÃ¼tzlichkeit:** â­â­â­â­â˜†

> _â€Ich mach das spÃ¤ter richtigâ€œ, hast du gesagt. Ein Jahr ist vergangen. Jetzt hast du Angst, die Datei Ã¼berhaupt zu Ã¶ffnen._

Spaghetti-Code ist der grÃ¶ÃŸte Feind produktiver Entwickler. Wenn die Lesbarkeit leidet, wird die Fehlersuche zur Qual und das HinzufÃ¼gen neuer Features zu einem Minenfeld. Dieser Prompt verwandelt die KI in deinen persÃ¶nlichen Robert C. Martin (Autor von _Clean Code_), der deinen Code schonungslos analysiert, aufrÃ¤umt und auf Hochglanz poliert.

---

## âš¡ï¸ 3-Zeilen-Zusammenfassung (TL;DR)

1. **Strukturierung:** Zerlegt Ã¼berlange Funktionen und entfernt redundanten Code (Extract Method).
2. **Namensgebung:** Ersetzt kryptische Variablen durch intuitive, aussagekrÃ¤ftige Namen.
3. **Modernisierung:** Aktualisiert veraltete Syntax auf den neuesten Sprachstandard und optimiert die Performance.

---

## ğŸš€ LÃ¶sung: Die "Clean Code" Waschmaschine

### ğŸ¥‰ Basic Version (Basisversion)

Nutze diese Version, wenn du unter Zeitdruck stehst und ein schnelles Refactoring benÃ¶tigst.

> **Rolle:** Du bist ein `[Clean Code Experte und Software Architekt]`.
> **Aufgabe:** Refactore diesen unsauberen Code. Mach ihn sauber, gut lesbar und leicht wartbar, ohne seine Funktion zu verÃ¤ndern.

<br>

### ğŸ¥‡ Pro Version (Expertenversion)

Verwende diesen detaillierten Prompt fÃ¼r tiefgreifende Architekturverbesserungen und Code-Reviews auf Senior-Level.

> **Rolle (Role):** Du bist ein erfahrener `[Clean Code Evangelist und Chief Software Architect]`.
>
> **Kontext (Context):**
>
> - Hintergrund: Mein aktueller Code funktioniert zwar, ist aber extrem unÃ¼bersichtlich, schwer zu testen und kaum wartbar (Technical Debt).
> - Ziel: Ein vollstÃ¤ndiges Refactoring nach den Prinzipien von Clean Code und SOLID, um die Skalierbarkeit und Lesbarkeit zu maximieren.
>
> **Aufgabe (Task):**
>
> 1. **[Naming Convention]**: Benenne Variablen und Funktionen aussagekrÃ¤ftig und intuitiv um (z.B. von `a` zu `userAge`).
> 2. **[Struktur]**: Zerlege monolithische Funktionen in kleinere, testbare Einheiten (Single Responsibility Principle) und entferne jegliche redundante Logik.
> 3. **[Modernisierung]**: Wende die aktuellsten Best Practices und modernste Syntax der jeweiligen Programmiersprache an (z.B. ES6+, Python 3.10+).
> 4. **[Analyse]**: Liefere einen strukturierten Vorher-Nachher-Vergleich und begrÃ¼nde jede Architektur-Entscheidung kurz.
>
> **EinschrÃ¤nkungen (Constraints):**
>
> - Die KernfunktionalitÃ¤t und das Ã¤uÃŸere Verhalten des Codes dÃ¼rfen sich unter keinen UmstÃ¤nden Ã¤ndern.
> - Formatiere das Ergebnis als Ã¼bersichtliche Markdown-Struktur mit entsprechenden Code-BlÃ¶cken.
> - FÃ¼ge Kommentare nur dort hinzu, wo das "Warum" erklÃ¤rt werden muss. Der Code selbst soll das "Wie" dokumentieren (SelbsterklÃ¤render Code).
>
> **Zielcode:**
>
> `[FÃ¼ge hier deinen Spaghetti-Code ein]`

---

## ğŸ’¡ Autorenkommentar (Insight)

Dieser Prompt ist ein absoluter Lebensretter, besonders wenn man Legacy-Code von Kollegen (oder dem eigenen Ich aus der Vergangenheit) erbt. Anstatt Stunden damit zu verbringen, die Logik hÃ¤ndisch zu entwirren, liefert die KI innerhalb von Sekunden einen soliden Ausgangspunkt.

**Pro-Tipp:** Nutze das Ergebnis nicht blind. Die KI ist fantastisch darin, "Early Returns" einzubauen und Variablen umzubenennen, aber bei komplexer GeschÃ¤ftslogik solltest du den refactorten Code immer durch deine Unit-Tests jagen. Wenn der Code vorher keine Tests hatte, bitte die KI in einem Folge-Prompt: _"Schreibe mir zuerst Unit-Tests fÃ¼r diesen unsauberen Code, bevor wir ihn refactoren."_ Das ist echtes Test-Driven Refactoring!

---

## ğŸ™‹ HÃ¤ufig gestellte Fragen (FAQ)

- **Q: Versteht die KI auch unternehmensinterne Coding-Richtlinien?**
  - A: Ja! Du kannst den Prompt einfach erweitern, z.B. _"Beachte, dass wir in unserem Projekt strikt funktional programmieren und Mutationen vermeiden."_ Je spezifischer der Kontext, desto besser das Ergebnis.

- **Q: Kann die KI dabei aus Versehen Bugs einbauen?**
  - A: Absolut. Obwohl wir in den EinschrÃ¤nkungen klarstellen, dass sich das Verhalten nicht Ã¤ndern darf, kann es bei komplexen NebenlÃ¤ufigkeiten (Concurrency) oder versteckten AbhÃ¤ngigkeiten zu Fehlern kommen. Verlasse dich beim Refactoring immer auf automatisierte Tests!

- **Q: Funktioniert das fÃ¼r jede Programmiersprache?**
  - A: Ja. Die Konzepte von Clean Code sind universell. Egal ob JavaScript, Python, Go oder Rust â€“ die KI passt die spezifischen Syntax-VorschlÃ¤ge an die von dir bereitgestellte Sprache an.

---

## ğŸ§¬ Prompt-Anatomie (Why it works?)

1. **Rollen-Empathie (Role):** Durch die Zuweisung der Rolle als "Chief Software Architect" zwingen wir das Modell, auf hÃ¶chstem qualitativem Niveau zu antworten, anstatt nur oberflÃ¤chliche Syntax-Korrekturen vorzunehmen.
2. **Klares Framework (Task):** Die Unterteilung in Naming, Struktur und Modernisierung gibt der KI einen exakten Leitfaden, _wie_ sie an das Refactoring herangehen soll, was Halluzinationen reduziert.
3. **ErklÃ¤rungszwang (Analyse):** Indem wir BegrÃ¼ndungen fÃ¼r die Ã„nderungen fordern, kÃ¶nnen wir als Entwickler nachvollziehen, _warum_ eine bestimmte Architektur gewÃ¤hlt wurde, und so selbst aus dem Prozess lernen.

---

## ğŸ“Š Beweis: Before & After

### âŒ Before (Eingabe)

```python
def calc(x, y):
    if x > 19:
        print("Erwachsener")
        p = y * 0.9
        return p
    else:
        print("SchÃ¼ler")
        return y
```

### âœ… After (Ergebnis)

```python
def calculate_discounted_price(age: int, base_price: float) -> float:
    ADULT_AGE_THRESHOLD = 20
    DISCOUNT_RATE = 0.9

    if age >= ADULT_AGE_THRESHOLD:
        print("Kunde ist volljÃ¤hrig.")
        return base_price * DISCOUNT_RATE

    print("Kunde ist SchÃ¼ler.")
    return base_price
```

**Warum ist das besser?**

- `calc` wurde zu `calculate_discounted_price` (Absicht ist sofort klar).
- Magische Zahlen (`19`, `0.9`) wurden in sprechende Konstanten (`ADULT_AGE_THRESHOLD`, `DISCOUNT_RATE`) umgewandelt.
- Typisierung (`int`, `float`) wurde hinzugefÃ¼gt (Python Modernisierung).
- Das Ã¼berflÃ¼ssige `else` wurde durch das "Early Return"-Pattern eliminiert, was die Verschachtelungstiefe reduziert.

---

## ğŸ¯ Fazit

Gut geschriebener Code liest sich so flÃ¼ssig und angenehm wie ein gutes Buch. RÃ¤ume deinen Code auf â€“ fÃ¼r dein zukÃ¼nftiges Ich und fÃ¼r die mentale Gesundheit deines Teams.

Lass die KI die Drecksarbeit machen. Mach pÃ¼nktlich Feierabend! ğŸ·
