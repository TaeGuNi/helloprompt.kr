---
layout: /src/layouts/Layout.astro
title: "我的代码是垃圾！整洁代码重构教练"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "编程/IT"
description: "将勉强能运行的‘屎山代码’重构为高可读性、高可维护性‘整洁代码’的AI教练提示词。"
tags: ["重构", "整洁代码", "开发者", "代码审查"]
---

# 📝 我的代码是垃圾！整洁代码重构教练

- **🎯 推荐对象:** 软件开发者、前端/后端工程师、代码审查员
- **⏱️ 所需时间:** 5 分钟 → 缩短至 1 分钟
- **🤖 推荐模型:** 所有对话型 AI (ChatGPT, Claude 3.5 Sonnet, Gemini 1.5 Pro 等)

- ⭐ **难度:** ⭐⭐☆☆☆
- ⚡️ **有效性:** ⭐⭐⭐⭐⭐
- 🚀 **实用性:** ⭐⭐⭐⭐☆

> _“总说以后再重构，一年过去了，现在的代码连碰都不敢碰。”_

意大利面条式的代码（Spaghetti Code）是每个开发者的梦魇。一旦代码可读性崩塌，不仅找 Bug 如同大海捞针，添加新功能更是步步惊心。这个提示词将为你召唤出“罗伯特·C·马丁（《Clean Code》作者）”的灵魂，对你的代码进行一次彻底的深度清洗，让它重新焕发光彩。

---

## ⚡️ 3 行总结 (TL;DR)

1. **消除冗余与方法提取 (Extract Method):** 将臃肿的代码块拆分为职责单一的纯净函数。
2. **规范命名 (Naming Convention):** 消灭无意义的变量名，替换为直观、表意明确的名称。
3. **性能与语法优化 (Modern Syntax):** 自动适配最新的语言特性（如 ES6+、Python 3.10+），提升执行效率。

---

## 🚀 解决方案："整洁代码清洗站"

### 🥉 Basic Version (基础版)

当你时间紧迫，只需快速获取重构结果时使用。

> **角色:** 你是一位资深的 `[整洁代码布道者兼首席架构师]`。
> **请求:** 请将以下这段勉强能跑的脏代码，重构为易于阅读和维护的整洁代码。

<br>

### 🥇 Pro Version (专家版)

当你需要高质量、符合行业标准且带有详细重构理由的代码时，请复制并使用以下提示词。

> **角色 (Role):** 你是一位资深的 `[整洁代码布道者兼首席架构师]`。
>
> **背景 (Context):**
>
> - 现状：我的代码虽然实现了业务功能，但结构混乱、难以阅读（Dirty Code），且存在潜在的技术债。
> - 目标：为了团队协作和未来的系统维护，需要对其进行彻底的重构。
>
> **任务 (Task):**
>
> 1. **[命名品味]**: 将所有模糊不清的变量名和函数名重命名为直观且具业务意义的名称（例：`a` -> `userAge`）。
> 2. **[结构优化]**: 拆分过长的函数，确保每个函数只做一件事（单一职责原则）；提取并合并重复的逻辑。
> 3. **[现代化语法]**: 在保证兼容性的前提下，尽可能应用最新的语言特性（如 ES6+、Python 3.10+、Java 17+ 等）。
> 4. **[修改对比]**: 请清晰地列出 Before & After 的对比，并逐条解释如此重构的底层逻辑和理由。
>
> **约束条件 (Constraints):**
>
> - 绝对不能改变代码原有的业务逻辑和执行结果（黑盒行为保持一致）。
> - 只在逻辑极度复杂或涉及核心业务规则的地方添加注释。（如果代码本身已足够自解释，请删除多余的废话注释）。
> - 输出格式：请使用清晰的 Markdown 排版，代码部分使用标准代码块。
>
> **目标代码:**
>
> `[在此处粘贴你的屎山代码]`

---

## 💡 作者笔记 (Insight)

在实际开发中，我们经常会因为“赶排期”而写出堆砌业务逻辑的临时代码。这个提示词的强大之处不仅在于它能帮你美化代码，更在于它输出的 **[修改对比]** 和 **重构理由**。
当你把这个提示词得到的结果贴在 Pull Request (PR) 的描述里时，不仅能让 Code Review 变成一种享受，还能潜移默化地提升你自己的代码品味。建议搭配使用 Claude 3.5 Sonnet，它在代码重构和上下文理解方面的表现堪称惊艳。

---

## 🙋 常见问题 (FAQ)

- **Q: AI 重构后的代码可以直接部署到生产环境吗？**
  - A: 绝对不行。虽然 AI 的重构逻辑通常很严谨，但你必须在合并前运行现有的单元测试（Unit Tests），确保原有功能没有被破坏。

- **Q: 如果我的代码长达上千行，这个提示词还管用吗？**
  - A: 对于超长文件，建议先人为地按功能模块（Class 或大的模块）切分成 200-300 行的代码块，然后分批次交给 AI 处理。一次性丢入上千行代码容易导致 AI 遗漏细节或产生幻觉。

---

## 🧬 提示词解剖 (Why it works?)

1. **顶级专家 Persona:** 赋予 AI “首席架构师”的身份，强制其不仅要写代码，还要以“布道者”的口吻解释背后的设计模式（Design Patterns）和架构原则。
2. **防范业务破坏 (Constraints):** 明确规定“行为绝对不能变”，这是重构的铁律，有效防止 AI 擅自篡改业务逻辑。
3. **强迫自解释 (Self-documenting):** 要求 AI 删除无用注释并通过变量名本身来说明逻辑，这完全契合《Clean Code》的核心价值观。

---

## 📊 证明: Before & After

### ❌ Before (输入)

```python
def calc(x, y):
    if x > 19:
        print("Adult")
        p = y * 0.9
        return p
    else:
        print("Student")
        return y
```

_（函数名 `calc` 毫无意义，变量 `p` 让人一头雾水，且包含不必要的 `else` 块）_

### ✅ After (提示词结果)

```python
def calculate_discounted_price(age, price):
    ADULT_AGE_THRESHOLD = 20
    DISCOUNT_RATE = 0.9

    if age >= ADULT_AGE_THRESHOLD:
        print("You are an adult.")
        return price * DISCOUNT_RATE

    print("You are a student.")
    return price
```

**[改善点解析]**

1. **命名表意**: `calc` -> `calculate_discounted_price`，一眼就能看懂函数在计算折扣价格。
2. **消灭魔法数字 (Magic Numbers)**: 将 `19` 和 `0.9` 声明为常量 `ADULT_AGE_THRESHOLD` 和 `DISCOUNT_RATE`，赋予其业务含义。
3. **减少嵌套 (Early Return)**: 移除了多余的 `else` 块，使用尽早返回模式，降低了代码的缩进深度，可读性直线上升。

---

## 🎯 结论

优秀的代码就像一篇优美的散文，读起来行云流水。为了未来的自己（以及不被接手代码的同事在背后吐槽），请养成随手打扫代码的好习惯。

现在，把重构的脏活交给 AI，准时下班去喝杯酒吧！🍷
