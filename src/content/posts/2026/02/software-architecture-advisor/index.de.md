---
layout: /src/layouts/Layout.astro
title: "Stoppt Spaghetti-Code! Architektur-Empfehlung perfekt fÃ¼r mein Projekt"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "Programmierung/Entwicklung"
description: "Ein Prompt, der die optimale Softwarearchitektur (wie MVC, Clean Architecture oder MSA) entwirft, passend zu Ihrem Projektumfang und Ihren Anforderungen."
tags: ["Architektur", "Design", "Designmuster", "Systemdesign", "MSA"]
---

# ğŸ“ Stoppt Spaghetti-Code! Die perfekte Architektur-Empfehlung fÃ¼r Ihr Projekt

- **ğŸ¯ Empfohlen fÃ¼r:** Entwickler, Tech Leads, Projektmanager
- **â±ï¸ Zeitaufwand:** 5 Minuten
- **ğŸ¤– Empfohlenes Modell:** Claude 3.5 Sonnet, GPT-4o (Modelle mit starker Logik)

- â­ **Schwierigkeit:** â­â­â˜†â˜†â˜†
- âš¡ï¸ **EffektivitÃ¤t:** â­â­â­â­â­
- ğŸš€ **Nutzen:** â­â­â­â­â˜†

> _"Es fÃ¤ngt immer harmlos an... Ein paar schnelle Features hier und da, und plÃ¶tzlich wird jede kleine Ã„nderung zum Albtraum. Beenden Sie das Architektur-Chaos, bevor es Ã¼berhaupt beginnt."_

Jedes noch so komplexe Softwareprojekt begann einmal als eine einzige, Ã¼berschaubare Datei. Doch wer ohne ein solides Fundament loslegt, versinkt unweigerlich im Sumpf der "technischen Schulden".
Ãœberlassen Sie die Erstellung des Bauplans (der Architektur) einer KI, die perfekt auf die Natur Ihres Projekts abgestimmt ist. So erhalten Sie von Tag 1 an ein stabiles, skalierbares GrundgerÃ¼st.

---

## âš¡ï¸ 3-Zeilen-Zusammenfassung (TL;DR)

1. **MaÃŸgeschneiderte Empfehlungen:** Finden Sie das perfekte Architekturmuster (MVC, MVVM, Clean Architecture, etc.) fÃ¼r Ihre spezifischen Anforderungen.
2. **Klare Verzeichnisstruktur:** Lassen Sie sich eine logische Ordnerstruktur inklusive der jeweiligen ZustÃ¤ndigkeiten generieren.
3. **Fundierte Entscheidungen:** Verstehen Sie sofort die Vor- und Nachteile der vorgeschlagenen Architektur fÃ¼r Ihr Vorhaben.

---

## ğŸš€ Die LÃ¶sung: "Der KI-Softwarearchitekt"

### ğŸ¥‰ Basic Version (GrundgerÃ¼st)

Nutzen Sie diesen Prompt, wenn Sie nur einen schnellen Ãœberblick oder einen groben Entwurf benÃ¶tigen.

> **Rolle:** Du bist ein erfahrener Softwarearchitekt.
> **Anfrage:** Schlage eine passende Softwarearchitektur und eine grundlegende Ordnerstruktur fÃ¼r `[Kurze Projektbeschreibung]` vor.

<br>

### ğŸ¥‡ Pro Version (Experten-Level)

Verwenden Sie diesen Prompt, wenn Sie ein tiefgehendes, produktionsreifes Systemdesign benÃ¶tigen.

> **Rolle (Role):** Du bist ein Principal Software Architect mit Ã¼ber 15 Jahren Erfahrung in der Skalierung und dem Design komplexer Systeme.
>
> **Kontext (Context):**
>
> - Hintergrund: Ich starte ein neues Projekt und muss mich fÃ¼r eine zukunftssichere Softwarearchitektur entscheiden. Hohe Wartbarkeit und Skalierbarkeit sind entscheidend.
> - Ziel: Einen klaren Bauplan und eine logische Verzeichnisstruktur zu erhalten, bevor die erste Zeile Code geschrieben wird.
>
> **Aufgabe (Task):**
>
> 1. Empfiehl die 2 **am besten geeigneten Architekturmuster** basierend auf meiner Projektbeschreibung.
> 2. Erstelle fÃ¼r deinen Top-Favoriten eine detaillierte **Verzeichnisstruktur** (als ASCII-Baumdiagramm).
> 3. ErklÃ¤re prÃ¤zise die Rolle und ZustÃ¤ndigkeit jedes Ordners und jeder Ebene.
>
> **Projektbeschreibung:**
> `[Beschreiben Sie Ihr Projekt detailliert. Z.B.: Eine E-Commerce-App mit hohem Traffic, entwickelt mit React Native und Node.js (Microservices). Zahlungsabwicklung und Echtzeit-Lieferverfolgung sind Kernfunktionen.]`
>
> **EinschrÃ¤nkungen (Constraints):**
>
> - Vermeide strikt Over-Engineering. Die LÃ¶sung muss realistisch und exakt an die TeamgrÃ¶ÃŸe sowie den Projektumfang angepasst sein.
> - Liefere stichhaltige, logische Argumente fÃ¼r deine Architekturwahl.
> - Gib die Antwort gut lesbar in Markdown aus.
>
> **Warnung (Warning):**
>
> - Erfinde keine unÃ¼blichen Muster. Halte dich ausschlieÃŸlich an bewÃ¤hrte Industrie-Standards. (Keine Halluzinationen)

---

## ğŸ’¡ Experten-Einblick (Insight)

Als Entwickler neigen wir oft dazu, sofort mit dem Coden beginnen zu wollen. Dieser Prompt ist ein echter "Lebensretter", weil er uns zwingt, einen Schritt zurÃ¼ckzutreten. Besonders effektiv ist er, weil wir das Modell explizit zwingen, _gegen_ Over-Engineering zu argumentieren. HÃ¤ufig schlagen KIs fÃ¼r simple To-Do-Apps unaufgefordert komplexe Microservice-Architekturen vor. Durch die gezielte EinschrÃ¤nkung im Pro-Prompt erhalten Sie stattdessen pragmatische, realitÃ¤tsnahe AnsÃ¤tze (wie Feature-Sliced Design oder modulare Monolithen), die Ihrem Team wochenlanges Refactoring ersparen.

---

## ğŸ™‹ HÃ¤ufig gestellte Fragen (FAQ)

- **Q: Welches KI-Modell eignet sich am besten fÃ¼r diese Aufgabe?**
  - A: FÃ¼r Architektur-Entscheidungen glÃ¤nzen Modelle mit starken logischen FÃ¤higkeiten wie Claude 3.5 Sonnet oder GPT-4o. Sie neigen bei Systemdesigns wesentlich weniger zu Halluzinationen als kleinere Modelle.

- **Q: Kann die KI auch bei bestehendem "Spaghetti-Code" helfen?**
  - A: Ja, absolut! Ã„ndern Sie den Kontext des Prompts leicht ab: _"Ich habe eine bestehende Codebasis, die zu einem Big Ball of Mud geworden ist. Hier ist meine aktuelle Verzeichnisstruktur... Wie kann ich schrittweise zu einer sauberen Architektur migrieren?"_

---

## ğŸ§¬ Prompt-Anatomie (Warum es funktioniert?)

1. **Senior-Level Persona:** Die Rolle als "Principal Software Architect" weist die KI an, nicht wie ein Junior-Entwickler zu denken, sondern strategisch und vorausschauend zu planen.
2. **Anti-Over-Engineering Constraint:** Die explizite Anweisung, Over-Engineering zu vermeiden, ist essenziell. Sie verhindert, dass die KI eine Netflix-Skalierung fÃ¼r eine App vorschlÃ¤gt, die nur 100 Nutzer hat.
3. **Strukturierte Ausgabe:** Durch die Forderung nach einem ASCII-Baumdiagramm wird abstrakte Theorie sofort in eine greifbare, direkt anwendbare Projektstruktur Ã¼bersetzt.

---

## ğŸ“Š Beweis: Vorher & Nachher

### âŒ Vorher (Eingabe)

```text
Projekt: Eine simple To-Do-App. Ich entwickle alleine und es gibt nicht viele Funktionen. Wie soll ich das aufbauen?
```

### âœ… Nachher (KI-Ergebnis)

```text
Empfohlene Architektur: Feature-Sliced Design (Feature-basierte Struktur)

Verzeichnisstruktur:
src/
â”œâ”€â”€ features/           # Module gekapselt nach Funktion
â”‚   â”œâ”€â”€ todos/
â”‚   â”‚   â”œâ”€â”€ components/ # UI-Komponenten nur fÃ¼r Todos
â”‚   â”‚   â”œâ”€â”€ hooks/      # Todo-spezifische Logik
â”‚   â”‚   â””â”€â”€ api/        # API-Aufrufe fÃ¼r Todos
â”‚   â””â”€â”€ auth/           # Login & Authentifizierung
â”œâ”€â”€ shared/             # Global genutzte Ressourcen
â”‚   â”œâ”€â”€ ui/             # Allgemeine Buttons, Inputs
â”‚   â””â”€â”€ utils/          # Hilfsfunktionen
â”œâ”€â”€ App.js
â””â”€â”€ index.js

BegrÃ¼ndung: FÃ¼r ein kleines Einzelentwickler-Projekt wÃ¤re Clean Architecture oder Hexagonal Architecture massives Over-Engineering. Die Feature-basierte Struktur hÃ¤lt zusammenhÃ¤ngenden Code nah beieinander. Das beschleunigt die Entwicklung enorm und bleibt dennoch Ã¼bersichtlich, falls das Projekt spÃ¤ter wÃ¤chst.
```

---

## ğŸ¯ Fazit

Niemand baut ein Haus, indem er einfach blind Steine aufeinanderstapelt â€“ ohne Bauplan stÃ¼rzt es irgendwann ein. Bei Software ist das nicht anders.

Nutzen Sie diesen KI-Architekten, um ein stabiles Fundament zu gieÃŸen, das auch in zehn Jahren noch problemlos erweitert werden kann. Viel Erfolg beim Coden ohne Chaos! ğŸ·
