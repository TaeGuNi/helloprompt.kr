---
layout: /src/layouts/Layout.astro
title: "내 코드가 스파게티? 리팩토링 전문가에게 맡겨보세요"
author: "ZZabbis"
date: "2026-02-12"
updatedDate: "2026-02-12"
category: "개발"
description: "「動くゴミ(Working Garbage)」を作ってはいけません。読みやすいコードこそが、優れたコードです。"
tags: ["코딩", "리팩토링", "클린코드"]
---

# 🍝 私のコードがスパゲッティ？リファクタリングの専門家にお任せください

- **🎯 おすすめの対象:** ジュニア開発者、コードレビューに疲れたシニア開発者、独学でプログラミングを学ぶ方
- **⏱️ 所要時間:** 1時間 → 3分に短縮
- **🤖 おすすめのモデル:** Claude 3.5 Sonnet, GPT-4o, Gemini 1.5 Pro (コーディング特化モデル推奨)

- ⭐ **難易度:** ⭐⭐☆☆☆
- ⚡️ **効果性:** ⭐⭐⭐⭐⭐
- 🚀 **活用度:** ⭐⭐⭐⭐⭐

> _「とりあえず動くからヨシ！」と放置したそのコード、数ヶ月後の自分が泣きながら解読することになりますよ。_

「とりあえず動くゴミ（Working Garbage）」を量産していませんか？
納期に追われて急いで書いたコードや、ロジックが複雑に絡み合ったスパゲッティコードは、後々のメンテナンスにおいて技術的負債となります。しかし、リファクタリングには時間も体力も必要です。

そんな時こそ、AIリファクタリング・エージェントの出番です。あなたの書いた乱雑なコードを、SOLID原則に基づいた美しく保守性の高い「クリーンコード」へと一瞬で変身させるプロンプトをご紹介します。

---

## ⚡️ 3行まとめ (TL;DR)

1. **AIを「シニアエンジニア」に任命する:** 単に「コードを直して」ではなく、具体的な役割と基準（SOLID原則など）を与えることが重要です。
2. **変更の理由を必ず明記させる:** コードのどこを、なぜ修正したのかを説明させることで、自身の学習にも繋がります。
3. **テストコードも一緒に生成:** リファクタリング後は、機能が壊れていないことを保証するためのテストが不可欠です。

---

## 🚀 解決策: "シニア・コードレビュアー" プロンプト

### 🥉 Basic Version（基本型）

サクッと可読性だけを上げたい場合に使用してください。

> **役割:** あなたは経験豊富なシニアソフトウェアエンジニアです。
> **要求:** 以下のコードをクリーンコードの原則に従ってリファクタリングし、読みやすく改善してください。
>
> ```[言語名]
> [ここにコードを貼り付け]
> ```

<br>

### 🥇 Pro Version（専門家型）

徹底的なリファクタリングと、アーキテクチャの改善が必要な場合に使用してください。

> **役割 (Role):**
> あなたは10年以上の経験を持つ、アーキテクチャとクリーンコードの専門家（シニアエンジニア）です。
>
> **状況 (Context):**
>
> - 背景: 現在のコードは動作していますが、可読性が低く、拡張性に欠けています。技術的負債を解消したいと考えています。
> - 目標: SOLID原則とデザインパターンを適用し、テスト可能で保守しやすいコードに書き換えること。
>
> **要求 (Task):**
>
> 1. 提供されたコードを分析し、問題点（Code Smells）をリストアップしてください。
> 2. `[プログラミング言語]` のベストプラクティスに従って、コードをリファクタリングしてください。
> 3. リファクタリングの前後で、どのような意図で変更を加えたのか、理由を明記してください。
> 4. 変更後のコードに対する基本的なユニットテスト（Unit Test）を作成してください。
>
> **対象コード:**
>
> ```[プログラミング言語]
> [ここにリファクタリングしたいコードを貼り付け]
> ```
>
> **制約事項 (Constraints):**
>
> - 既存のビジネスロジックや機能（振る舞い）は絶対に変更しないでください。
> - 出力形式は、Markdownのコードブロックを使用し、説明は簡潔にまとめてください。
>
> **注意事項 (Warning):**
>
> - 推測で勝手に機能を追加したり、不要なライブラリをインポートしたりしないでください。

---

## 💡 作成者のコメント (Insight)

このプロンプトの最大の価値は、単に綺麗なコードを得ることではなく、**「なぜそのように修正したのか」というシニアエンジニアの思考プロセスを学べる点**にあります。特にジュニア開発者の場合、Pro Versionで出力された「問題点のリストアップ」と「変更の意図」を読むことで、自分自身のコーディングの癖や、見落としていたアンチパターンに気付くことができます。

実務で活用する際は、関数やクラス単位など、ある程度小さく分割してプロンプトに入力すると、AIのハルシネーション（嘘の出力）を防ぎ、より精度の高いリファクタリング結果を得られます。

---

## 🙋 よくある質問 (FAQ)

- **Q: 会社の本番コードをそのまま入力しても大丈夫ですか？**
  - A: セキュリティや機密保持の観点から、社外秘の情報（APIキーや独自のパスワード、個人情報など）は絶対に除外してから入力してください。また、社内のAI利用ガイドラインに必ず従ってください。

- **Q: リファクタリング後、バグが発生することはありますか？**
  - A: AIも完璧ではないため、エッジケースで挙動が変わる可能性があります。だからこそ、プロンプトで「ユニットテストの作成」を指示し、変更後に必ずテストを実行して動作確認を行うことが重要です。

---

## 🧬 プロンプトの解剖学 (Why it works?)

1.  **Code Smellsの指摘:** 単に直すだけでなく、まず「どこが悪いのか」を分析させることで、AIの出力精度が向上し（Chain-of-Thought効果）、ユーザーの学習にも貢献します。
2.  **ビジネスロジック保持の制約:** 「振る舞いを変えない」という強い制約（Constraints）を設けることで、リファクタリングの本来の定義を守らせ、予期せぬ機能改変を防ぎます。

---

## 📊 証明: Before & After

### ❌ Before (入力 - JavaScriptの例)

```javascript
function calc(a, b, c) {
  let res = 0;
  if (c === "add") {
    res = a + b;
  } else if (c === "sub") {
    res = a - b;
  } else if (c === "mul") {
    res = a * b;
  }
  return res;
}
```

### ✅ After (結果)

```javascript
/**
 * 2つの数値に対して指定された演算を実行します。
 * @param {number} a - 最初の数値
 * @param {number} b - 2番目の数値
 * @param {string} operation - 演算の種類 ('add', 'sub', 'mul')
 * @returns {number} 演算結果
 * @throws {Error} サポートされていない演算子が指定された場合
 */
function calculate(a, b, operation) {
  const operations = {
    add: (x, y) => x + y,
    sub: (x, y) => x - y,
    mul: (x, y) => x * y,
  };

  const selectedOperation = operations[operation];

  if (!selectedOperation) {
    throw new Error(`サポートされていない演算子です: ${operation}`);
  }

  return selectedOperation(a, b);
}
```

_(※ AIによる解説: マジックナンバーの排除、オブジェクト・リテラルを活用した条件分岐の簡略化、エラーハンドリングの追加を行いました。)_

---

## 🎯 結論

「動くゴミ」を放置することは、未来の自分への裏切りです。
AIという優秀なシニアエンジニアをペアプログラミングの相棒として活用し、今日からクリーンコードを実践しましょう。

さあ、コードを磨き上げて、定時退社しましょう！ 🍷
