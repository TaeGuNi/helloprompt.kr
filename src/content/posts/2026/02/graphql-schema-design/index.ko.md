---
layout: /src/layouts/Layout.astro
title: "GraphQL 스키마 설계: REST API에서 넘어오기"
author: "ZZabbis"
date: "2026-02-12"
updatedDate: "2026-02-12"
category: "백엔드/DB"
description: "오버페칭(Over-fetching) 없는 깔끔한 API. 프론트엔드가 행복해지는 GraphQL 스키마 디자인 패턴."
tags: ["GraphQL", "API", "백엔드", "스키마", "Apollo"]
---

# 🕸️ GraphQL 스키마 설계: REST API에서 넘어오기

- **🎯 추천 대상:** "API 명세서 수정 좀 그만하자"고 외치는 백엔드 개발자, "불필요한 데이터 때문에 앱이 무거워요"라고 호소하는 프론트엔드 개발자
- **⏱️ 소요 시간:** 10분 (스키마 초안 작성 및 최적화)
- **🤖 추천 모델:** ChatGPT-4o, Claude 3.5 Sonnet (데이터 구조화 및 리졸버 설계 탁월)

- ⭐ **난이도:** ⭐⭐⭐☆☆
- ⚡️ **효과성:** ⭐⭐⭐⭐⭐
- 🚀 **활용도:** ⭐⭐⭐⭐☆

> _"화면에 유저 이름표 하나 띄우는데, 왜 API는 집 주소부터 전화번호, 가입일까지 전부 다 끌고 오는 걸까요?"_

REST API의 고질적인 문제, 바로 **오버페칭(Over-fetching)**과 **언더페칭(Under-fetching)**입니다. 프론트엔드에서 화면 하나를 그리기 위해 여러 개의 API 엔드포인트를 호출하거나, 필요 이상의 거대한 데이터를 받아와 필터링해야만 하죠. GraphQL은 이 비효율적인 통신 방식을 근본적으로 바꿉니다. 프론트엔드에게 거대한 뷔페 접시(Schema)를 제공하고, **"정확히 원하는 것만"** 골라 담아 먹을 수 있는 주문서(Query)를 작성하게 하세요.

---

## ⚡️ 3줄 요약 (TL;DR)

1. **Schema (스키마):** API가 제공할 수 있는 모든 데이터의 형태와 관계를 정의합니다. (뷔페 메뉴판)
2. **Query (쿼리):** 프론트엔드가 필요한 데이터만 콕 집어 요청하는 주문서입니다. (오버페칭 해결)
3. **Resolver (리졸버):** 요청받은 데이터를 실제 DB나 외부 API에서 안전하고 효율적으로 가져오는 로직입니다.

---

## 🚀 해결책: "GraphQL Schema & Resolver Architect"

### 🥉 Basic Version (기본 REST 변환)

기존 REST API 명세서를 빠르게 GraphQL 스키마로 전환하고 싶을 때 사용하세요.

> **역할:** 너는 시니어 백엔드 엔지니어야.
>
> **요청:** 아래 제공된 REST API 응답 JSON을 기반으로, 가장 이상적인 GraphQL 스키마(`type`)를 정의하고 데이터를 요청하는 쿼리 예시를 작성해줘.
>
> **데이터:** `[여기에 기존 REST API JSON 응답 복사/붙여넣기]`

<br>

### 🥇 Pro Version (전문가형: N+1 문제 및 페이지네이션 완벽 설계)

성능 최적화와 대용량 데이터 처리를 고려한 실무용 스키마 설계가 필요할 때 사용하세요.

> **역할 (Role):** 너는 대규모 트래픽을 처리하는 GraphQL 서버 아키텍트야.
>
> **상황 (Context):**
>
> - 우리는 현재 블로그 기반의 콘텐츠 플랫폼을 개발 중이야.
> - 사용자가 `Post`(게시글) 목록을 불러올 때, 각 게시글의 `Author`(작성자) 정보와 최신 `Comment`(댓글) 3개도 함께 렌더링해야 해.
> - 단순히 구현할 경우, 게시글 100개를 조회할 때 작성자와 댓글을 가져오기 위해 100번 이상의 추가 쿼리가 발생하는 **N+1 문제**가 예상돼.
>
> **요청 (Task):**
>
> 1.  **Schema Design:** 위 상황에 맞는 GraphQL 스키마를 정의해줘.
> 2.  **DataLoader (N+1 해결):** N+1 문제를 근본적으로 해결하기 위해, `DataLoader` 패턴(Batching & Caching)을 적용한 리졸버(Resolver) 코드를 Node.js/TypeScript 기반으로 작성해줘.
> 3.  **Pagination:** 무한 스크롤(Infinite Scroll) 프론트엔드 구현을 위해, 리스트 반환 시 **커서 기반 페이지네이션(Cursor-based Pagination)** 스키마를 설계해줘. (반드시 Relay 표준 방식인 `edges`, `node`, `pageInfo` 구조를 따를 것)
> 4.  **Error Handling:** 에러 발생 시 단순히 `data: null`을 반환하지 않고, `errors` 배열에 에러 코드와 사용자 친화적인 메시지를 담아 규격화하는 방식을 적용해.
>
> **제약사항 (Constraints):**
>
> - 코드는 즉시 복사하여 사용할 수 있도록 마크다운 코드 블록으로 제공해줘.
> - 쿼리 성능 저하를 막기 위해, 악의적인 깊은 쿼리(Deep Query)를 방지하는 개념도 주석으로 간단히 추가해.

---

## 💡 작성자 코멘트 (Insight)

GraphQL은 데이터 간의 관계를 **'그래프(Graph)'** 형태로 탐색합니다. 유저 -> 글 -> 댓글 -> 또 다른 유저 -> 또 다른 글... 이런 식으로 클라이언트가 쿼리를 무한히 깊게 타고 들어갈 수 있습니다. 이를 방치하면 악의적인(또는 실수로 작성된) 단 하나의 쿼리만으로 서버의 DB 자원을 고갈시켜 서버가 다운될 수 있습니다.

실무에 GraphQL을 도입할 때는 반드시 **쿼리 복잡도 제한(Query Complexity Limit)**이나 **최대 깊이 제한(Maximum Depth Limit)** 설정을 추가해야 합니다. AI에게 프롬프트를 요청할 때 이 보안 조치를 구현하는 방식을 함께 물어보는 것이 좋습니다. 또한, Apollo Server 플러그인을 활용하면 이러한 방어 로직을 매우 쉽게 구현할 수 있습니다.

---

## 🙋 자주 묻는 질문 (FAQ)

- **Q: GraphQL은 캐싱이 어렵다던데 사실인가요?**
  - A: 절반은 맞습니다. REST API는 URL 단위로 HTTP 레벨의 캐싱(CDN, 브라우저)이 매우 직관적이지만, GraphQL은 보통 단일 `/graphql` 엔드포인트에 `POST` 요청을 보내기 때문에 네트워크 레벨 캐싱이 까다롭습니다. 하지만, **Apollo Client** 같은 강력한 프론트엔드 상태 관리 라이브러리를 사용하면 정규화된(Normalized) 로컬 인메모리 캐싱을 기가 막히게 지원하여 네트워크 요청 자체를 획기적으로 줄여줍니다.

- **Q: 파일 업로드(Multipart) 처리는 어떻게 하나요?**
  - A: GraphQL을 통한 파일 업로드 구현(예: `graphql-upload` 스펙)은 가능하지만, 설정이 복잡하고 디버깅이 까다롭습니다. 실무에서는 정신 건강과 유지보수성을 위해 텍스트 데이터는 GraphQL로, **파일 업로드 전용 엔드포인트는 REST API로 분리하는 하이브리드 아키텍처**를 강력히 권장합니다.

---

## 🧬 프롬프트 해부 (Why it works?)

1.  **핵심 취약점(N+1 문제) 선제적 제시:** 프롬프트 내에서 데이터베이스 통신의 최대 약점인 N+1 문제를 명확히 짚어주었습니다. 이로 인해 AI가 단순히 "작동하는 기초 코드"가 아니라, 실무에 즉시 투입 가능한 수준의 **'성능 최적화된 아키텍처(DataLoader)'**를 결과물로 도출하게 만듭니다.
2.  **글로벌 표준(Relay) 강제화:** 페이지네이션은 개발자마다 구현 방식이 천차만별입니다. "Relay 표준"이라는 구체적인 키워드 제약을 줌으로써, 페이스북(Meta)이 확립한 가장 검증되고 프론트엔드와 연동하기 쉬운 규격화된 스키마 구조를 보장받을 수 있습니다.

---

## 📊 증명: Before & After

### ❌ Before (기존 REST 방식)

게시글 하나와 연관된 유저, 댓글을 렌더링하기 위해 폭포수(Waterfall) 형태의 연속된 네트워크 호출이 발생합니다. (네트워크 왕복 3회 발생, 느린 로딩 🐢)

```http
GET /posts/123
GET /users/45  (post 응답을 받은 후 호출)
GET /posts/123/comments (동시 호출)
```

### ✅ After (GraphQL 최적화 방식)

프론트엔드에서 정확히 필요한 필드만 구조화하여 단 한 번의 요청으로 조립된 완제품을 받아옵니다. (네트워크 왕복 1회, 오버페칭 제로 🚀)

```graphql
query GetPostDetails {
  post(id: "123") {
    title
    content
    author {
      name
      profileImageUrl
    }
    comments(first: 3) {
      edges {
        node {
          body
          createdAt
        }
      }
    }
  }
}
```

---

## 🎯 결론

API 명세서를 엑셀이나 위키에 일일이 업데이트하느라 야근하지 마세요.
GraphQL은 정의된 **스키마 자체가 곧 완벽한 명세서**로 작동하며, 스웨거(Swagger)보다 훨씬 직관적인 탐색 도구(GraphiQL)를 기본 제공합니다.

더 이상 데이터 구조 때문에 프론트엔드와 백엔드가 감정싸움을 할 필요가 없습니다.
우아한 데이터 통신, **GraphQL**과 함께 평화를 찾으세요. 🍷
