---
layout: /src/layouts/Layout.astro
title: "编写测试代码，5 分钟搞定的提示词"
author: "Zzabbis"
date: "2026-02-04"
updatedDate: "2026-02-04"
category: "编码/开发"
description: "把枯燥繁琐的单元测试（Unit Test）编写工作交给 AI 吧。轻松挑战 100% 覆盖率！"
tags: ["测试代码", "TDD", "Jest", "PyTest", "QA"]
---

# 📝 编写测试代码，5 分钟搞定的提示词

- **🎯 推荐对象:** 开发者、QA 工程师、所有希望提升代码质量的人
- **⏱️ 所需时间:** 30 分钟 → 缩短至 5 分钟
- **🤖 推荐模型:** 所有对话型 AI (ChatGPT, Claude, Gemini 等)

- ⭐ **难度:** ⭐⭐☆☆☆
- ⚡️ **有效性:** ⭐⭐⭐⭐⭐
- 🚀 **实用性:** ⭐⭐⭐⭐☆

> _“业务代码都写不完，哪有时间去补全那些枯燥的测试覆盖率？”_

虽然大家都知道单元测试（Unit Test）的重要性，但真要动起手来，往往会发现编写测试代码比实现主逻辑还要耗时。不仅要考虑各种极端边缘情况（Edge Cases），还要费尽心思去处理复杂的模拟对象（Mocking）……是不是想想就头疼？

现在，你只需复制粘贴业务逻辑代码，那些繁琐、细致的测试用例生成工作，统统交给 AI 来搞定吧！

---

## ⚡️ 3 行总结 (TL;DR)

1. **全面覆盖：** 不仅覆盖正常运行的快乐路径（Happy Path），更严密防范各种异常边缘情况。
2. **完美兼容：** 无缝支持主流测试框架（Jest, PyTest, JUnit 等）的语法特性。
3. **自动 Mock：** 智能识别外部依赖并自动生成精准的 Mock 数据和隔离逻辑。

---

## 🚀 解决方案：“单元测试自动生成器”

### 🥉 Basic Version (基础版)

当你只需要快速生成基本的测试框架和用例时使用。

> **角色:** 你是一位严谨且追求完美的 QA 工程师兼测试自动化专家。
> **请求:** 请为我提供的代码编写单元测试（Unit Test），要求尽可能覆盖所有的正常场景和异常情况，挑战 100% 测试覆盖率。

<br>

### 🥇 Pro Version (专家版)

当你需要深入复杂的业务逻辑，并要求极高质量的覆盖率和详细注释时使用。

> **角色 (Role):** 你是一位严谨、细致且追求完美的资深 QA 工程师兼测试自动化专家。
>
> **情况 (Context):**
>
> - 背景：我有一段使用 `[编程语言/框架，例如：Node.js/Express]` 编写的业务代码。
> - 目标：为了确保生产环境的绝对稳定，我需要为其编写高质量的单元测试（Unit Test）。
>
> **请求 (Task):**
>
> 1. 深度分析提供的代码逻辑，优先列出详尽的测试用例清单（必须包含：成功场景、失败场景、边界值分析）。
> 2. 使用 `[测试框架名称，例如：Jest, PyTest, JUnit]` 编写符合行业规范且可直接执行的测试代码。
> 3. 如果代码中存在数据库调用、API 请求或其他外部依赖，请务必提供完整的 Mocking 处理方案。
> 4. 为每一个测试用例添加清晰的注释，说明该用例的具体验证目标。
>
> **目标代码:**
> `[请在此处粘贴需要测试的业务代码]`
>
> **约束条件 (Constraints):**
>
> - 测试覆盖率必须尽可能达到 100%，不仅测试功能，还要覆盖所有异常抛出分支。
> - 输出的代码必须是完整的、可立即复制并在本地环境中执行的形式。
> - 所有的测试用例描述和注释必须使用专业的中文编写。
>
> **警告 (Warning):**
>
> - 不要捏造项目中不存在的依赖库方法。如果遇到不确定的外部依赖，请在注释中标注需要开发者手动补充完善。

---

## 💡 作者评论 (Insight)

在实际的敏捷开发流程中，测试驱动开发（TDD）往往因为排期紧凑而沦为一句口号。这个提示词的真正价值，不在于盲目追求“100%覆盖率”这个数字，而在于**它能瞬间打破你编写测试的“冷启动”障碍**。

当你把复杂的函数丢给大模型（强烈推荐 Claude 3.5 Sonnet 或代码能力极强的 Gemini 处理此类任务），它能在一秒钟内帮你搭好骨架并找出你可能忽略的边界条件（如 `null` 处理或异常捕获）。即使 AI 生成的代码偶尔需要微调依赖路径，它也为你节省了 90% 查阅 Mock 文档和手写样板代码（Boilerplate）的时间。尤其在重构遗留代码（Legacy Code）时，先用这个提示词跑出一套基础测试网，能让你后续修改代码时底气十足。

---

## 🙋 常见问题 (FAQ)

- **Q: AI 生成的 Mock 代码总是报错找不到路径，怎么解决？**
  - A: 外部依赖非常复杂时，AI 可能会猜错你的项目目录结构。建议在 `[请在此处粘贴需要测试的业务代码]` 下方，顺便提供一两个你们项目中已有的正确 Mock 示例片段，或者明确告诉它你的依赖绝对路径，AI 的准确率会产生质的飞跃。

- **Q: 这个提示词可以用来写集成测试（Integration Test）或 E2E 测试吗？**
  - A: 这个提示词专为底层的单元测试优化。如果是 E2E 测试（例如 Playwright 或 Cypress），你需要额外补充 DOM 结构（HTML 代码）和具体的用户交互流程说明，建议拆分成更细致的任务步骤交给 AI。

---

## 🧬 提示词解剖 (Why it works?)

1. **确立专家角色 (Role):** 赋予 AI “追求完美的 QA 工程师”人设，迫使它不仅关注代码跑通，更关注测试的严密性和覆盖边界。
2. **强制列出清单 (Task):** 要求在写代码前先输出“测试用例清单”。这属于典型的思维链（Chain of Thought）技巧，让 AI 先理清逻辑再动手编写断言，大幅减少场景遗漏。
3. **明确 Mock 指示 (Constraints):** 现代应用开发中最大的痛点就是处理错综复杂的外部依赖。强制要求处理 Mock，能防止 AI 写出试图连接真实数据库的无效测试代码。

---

## 📊 证明: Before & After

### ❌ Before (输入的业务代码)

```javascript
// 一个简单的用户余额扣除逻辑
function deductBalance(user, amount) {
  if (amount <= 0) throw new Error("扣除金额必须大于 0");
  if (user.balance < amount) throw new Error("余额不足");
  user.balance -= amount;
  return user.balance;
}
```

### ✅ After (AI 生成的测试代码)

```javascript
describe("deductBalance 函数测试", () => {
  let mockUser;

  beforeEach(() => {
    // 每次测试前初始化干净的用户状态
    mockUser = { id: 1, balance: 100 };
  });

  // 1. 成功场景测试 (Happy Path)
  test("正常扣除金额时，应返回正确的剩余余额并更新用户对象", () => {
    const newBalance = deductBalance(mockUser, 30);
    expect(newBalance).toBe(70);
    expect(mockUser.balance).toBe(70);
  });

  // 2. 异常场景测试 - 边界值分析
  test("扣除金额为 0 时，应抛出异常", () => {
    expect(() => deductBalance(mockUser, 0)).toThrow("扣除金额必须大于 0");
  });

  test("扣除金额为负数时，应抛出异常", () => {
    expect(() => deductBalance(mockUser, -10)).toThrow("扣除金额必须大于 0");
  });

  // 3. 异常场景测试 - 业务规则限制
  test("扣除金额大于用户可用余额时，应抛出余额不足异常", () => {
    expect(() => deductBalance(mockUser, 150)).toThrow("余额不足");
  });
});
```

---

## 🎯 结论

Bug 如果在部署到生产环境后才被发现，其排查和修复的成本会飙升百倍以上。
在开发阶段巧妙利用这个提示词消灭隐患，让你的代码库更加稳健坚不可摧。现在，自信地点击合并（Merge）按钮吧！🍷
