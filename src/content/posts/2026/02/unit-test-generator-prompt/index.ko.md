---
layout: /src/layouts/Layout.astro
title: "테스트 코드 작성, 5분 만에 끝내는 프롬프트"
author: "Zzabbis"
date: "2026-02-07T09:10:33.155Z"
updatedDate: "2026-02-07T09:10:33.155Z"
category: "코딩/개발"
description: "지루하고 귀찮은 유닛 테스트(Unit Test) 작성을 AI에게 맡겨보세요. 커버리지 100%에 도전!"
tags: ["테스트코드", "TDD", "Jest", "PyTest", "QA"]
---

# 📝 테스트 코드 작성, 5분 만에 끝내는 프롬프트

- **🎯 추천 대상:** 주니어 개발자, 프론트엔드/백엔드 엔지니어, QA
- **⏱️ 소요 시간:** 30분 → 5분 단축
- **🤖 추천 모델:** 코딩 특화 모델 (Claude 3.5 Sonnet, GPT-4o 등)

- ⭐ **난이도:** ⭐⭐☆☆☆
- ⚡️ **효과성:** ⭐⭐⭐⭐⭐
- 🚀 **활용도:** ⭐⭐⭐⭐☆

> _"코드 짜기도 바쁜데 테스트 코드는 도대체 언제 만들죠? 배포일은 내일인데!"_

테스트 코드의 중요성은 머리로는 알지만, 막상 짜려면 메인 비즈니스 로직보다 시간이 더 걸리곤 합니다. Edge Case 고민하랴, 수많은 외부 API 의존성 Mocking 하랴... 결국 "일단 이번 배포는 그냥 가시죠"라는 타협을 하게 됩니다.

이제 메인 로직만 복사해서 붙여넣으세요. 지루한 보일러플레이트 작성부터 꼼꼼한 예외 케이스(Edge Case) 테스트까지, AI가 완벽한 유닛 테스트 코드를 대신 작성해 드립니다.

---

## ⚡️ 3줄 요약 (TL;DR)

1. **Happy Path부터 Edge Case까지:** 정상 동작은 물론 예외 상황까지 꼼꼼하게 커버하는 테스트 시나리오를 자동 도출합니다.
2. **원하는 프레임워크 맞춤형:** Jest, PyTest, JUnit 등 현재 프로젝트에서 사용 중인 테스트 프레임워크 문법에 맞춰 즉시 실행 가능한 코드를 생성합니다.
3. **까다로운 Mocking 자동화:** 번거로운 외부 API 호출이나 DB 의존성을 파악하여 알아서 Mock 데이터와 Stub을 구성해 줍니다.

---

## 🚀 해결책: "무한 테스트 코드 생성기"

### 🥉 Basic Version (기본형)

빠르게 기본적인 테스트 구조만 잡고 싶을 때 사용하세요.

> **역할:** 너는 완벽주의 성향을 가진 시니어 QA 엔지니어이자 테스트 자동화 전문가야.
> **요청:** 다음 코드를 분석해서 예외 케이스를 포함한 유닛 테스트(Unit Test) 코드를 작성해줘.

<br>

### 🥇 Pro Version (전문가형)

복잡한 비즈니스 로직, 의존성 Mocking, 높은 커버리지가 필요할 때 사용하세요.

> **역할 (Role):** 너는 꼼꼼하고 완벽주의적인 10년 차 시니어 QA 엔지니어이자 테스트 자동화 전문가야.
>
> **상황 (Context):**
>
> - 배경: 나는 현재 `[사용 언어 및 프레임워크 (예: TypeScript, Jest)]` 환경에서 개발 중이야.
> - 목표: 새로 작성한 비즈니스 로직의 신뢰성을 보장하고, Test Coverage 100%를 달성하기 위해 촘촘한 유닛 테스트(Unit Test)를 작성해야 해.
>
> **요청 (Task):**
>
> 1. 제공된 코드를 분석하여 **테스트 케이스 목록**을 먼저 마크다운 리스트로 정리해줘. (Happy Path, 예외/실패 케이스, 경계값 분석 필수 포함)
> 2. `[사용할 테스트 라이브러리 (예: Jest)]`를 사용하여 즉시 실행 가능한 완전한 테스트 코드를 작성해줘.
> 3. 코드 내에 외부 의존성(API 호출, DB 연결, 날짜/시간 등)이 있다면 완벽하게 Mocking 처리를 해줘.
> 4. 각 `it` 또는 `test` 블록 내부에는 GIVEN-WHEN-THEN 패턴에 맞춰 주석을 달아줘.
>
> **코드:**
>
> ```
> [여기에 테스트할 코드를 붙여넣으세요]
> ```
>
> **제약사항 (Constraints):**
>
> - 출력 형식은 마크다운 코드블럭으로 제공해줘.
> - 테스트 설명(Description)은 반드시 명확한 한국어로 작성해줘. (예: "0으로 나누기를 시도하면 에러를 던져야 한다")
> - 코드는 일부만 작성하지 말고(No placeholder), 복사 후 즉시 실행할 수 있는 완성된 형태로 제공해.
>
> **주의사항 (Warning):**
>
> - 존재하지 않는 라이브러리의 메서드를 지어내지 마. (환각 방지)

---

## 💡 작성자 코멘트 (Insight)

이 프롬프트는 단순한 "테스트 코드 짜줘" 이상의 가치를 지닙니다. 특히 **Task 1번의 '테스트 케이스 목록 도출'** 과정이 핵심입니다. AI가 코드를 어떻게 분석했는지 먼저 눈으로 확인하면, 개발자가 미처 생각하지 못했던 엣지 케이스(예: Null 입력, 타입 불일치 등)를 방어할 수 있습니다.

실무에서는 테스트 프레임워크마다 Mocking 문법이 조금씩 다릅니다. 만약 결과물에서 Mocking 방식이 프로젝트 컨벤션과 다르다면, 프롬프트에 `[우리 팀의 Mocking 예시 코드]`를 한 스니펫 정도 추가해 보세요. AI가 팀의 스타일을 학습하여 훨씬 더 완벽한 코드를 뱉어낼 것입니다.

---

## 🙋 자주 묻는 질문 (FAQ)

- **Q: 코드가 너무 길어서 AI가 중간에 끊기면 어떡하나요?**
  - A: 함수나 클래스 단위로 쪼개서 요청하는 것이 좋습니다. 파일 전체를 통째로 넣으면 AI가 중요한 엣지 케이스를 놓치기 쉽습니다. 단일 책임 원칙(SRP)이 지켜진 함수 하나씩 테스트를 요청해 보세요.

- **Q: DB 연결 코드가 포함되어 있는데 테스트 코드를 짤 수 있나요?**
  - A: 네! 이 프롬프트는 '외부 의존성 Mocking'을 지시하고 있습니다. AI가 DB Repository나 ORM 호출 부분을 감지하고 알아서 가짜 객체(Mock)로 대체하는 코드를 작성해 줄 것입니다.

---

## 🧬 프롬프트 해부 (Why it works?)

1. **Role 부여:** "완벽주의 시니어 QA 엔지니어"라는 페르소나를 통해, 대충 짜는 테스트가 아닌 경계값(Boundary)까지 집요하게 파고드는 코드를 작성하도록 유도했습니다.
2. **GIVEN-WHEN-THEN 패턴 강제:** 테스트 코드의 가독성을 높이는 표준 패턴을 주석으로 달게 하여, 다른 팀원이 코드를 읽을 때도 쉽게 이해할 수 있도록 구조화했습니다.
3. **Mocking 자동화 지시:** 개발자들이 테스트 작성 시 가장 시간을 많이 뺏기는 '의존성 주입 및 Mocking' 부분을 AI에게 명시적으로 위임하여 시간 절감 효과를 극대화했습니다.

---

## 📊 증명: Before & After

### ❌ Before (입력 코드)

```javascript
// 단순한 입력 코드 예시
function calculateDiscount(price, discountRate) {
  if (price < 0 || discountRate < 0) {
    throw new Error("유효하지 않은 값입니다.");
  }
  if (discountRate > 100) {
    return 0; // 100% 이상 할인은 무료
  }
  return price - price * (discountRate / 100);
}
```

### ✅ After (결과)

```javascript
describe("calculateDiscount 함수 테스트", () => {
  // 1. 정상 동작 테스트 (Happy Path)
  it("정상적인 가격과 할인율이 주어지면 할인이 적용된 가격을 반환해야 한다", () => {
    // GIVEN
    const price = 10000;
    const discountRate = 20;
    // WHEN
    const result = calculateDiscount(price, discountRate);
    // THEN
    expect(result).toBe(8000);
  });

  // 2. 경계값 테스트 (Edge Case)
  it("할인율이 100%를 초과하면 0원을 반환해야 한다", () => {
    // GIVEN & WHEN
    const result = calculateDiscount(10000, 110);
    // THEN
    expect(result).toBe(0);
  });

  // 3. 예외 처리 테스트 (Failure Case)
  it("가격이 음수일 경우 에러를 던져야 한다", () => {
    // GIVEN, WHEN & THEN
    expect(() => calculateDiscount(-5000, 10)).toThrow(
      "유효하지 않은 값입니다.",
    );
  });
});
```

---

## 🎯 결론

버그는 프로덕션에 배포된 후에 발견하면 수정 비용이 100배로 뜁니다.
이제 핑계는 그만! 이 프롬프트로 개발 단계에서 꼼꼼하게 버그를 박멸하고, 자신 있게 'Merge' 버튼을 누르세요.

오늘도 칼퇴하세요! 🍷
